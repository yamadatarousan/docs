# 1

設計方針：確率的な探索主体を開発系に入れたときの安定化条件

本設計では、AIを「知識を保持し一貫した判断を行う主体」としてではなく、
読み込んだ文脈に対して確率的に次の一手を生成する探索主体として扱う。

曖昧さを含む文脈を入力とする限り、AIの出力は本質的に多分岐になる。
それぞれの出力は局所的にはもっともらしく見えるが、そのすべてがシステム全体にとって適切であるとは限らない。

したがって、AIを開発に導入することは
「実装を自動化する」ことではなく、
実装の探索が高速かつ多分岐になる状況を受け入れることを意味する。

問題は、探索によって不適切な枝が生成されること自体ではない。
問題になるのは、不適切な枝がそのまま統合され、
以降の開発における前提として固定化されてしまうことである。

この観点から見ると、本設計が扱う課題は
「確率的な探索主体を開発系に入れたときの安定化条件」になる。

ここで言う安定化とは、
探索（生成）が継続しても、システムが持つべき性質が崩れないことを指す。
言い換えれば、

探索（生成）と固定（統合）が分離され、
固定されるのは検証を通過したものだけ、
という構造を作ること
である。

この構造を成立させるためには、二つの仕組みが必要になる。

一つは、探索の範囲をあらかじめ制限することだ。
アーキテクチャ、境界、責務分離、依存方向といった設計要素は、
AIに正解を教えるためのものではなく、
探索が向かってよい方向と、向かってはいけない方向を定めるためのものとして機能する。

もう一つは、探索の結果を選別することだ。
生成された実装や変更のうち、
設計として許容できないものが統合されるのを防ぐ必要がある。
そのために、契約、不変条件、互換性といった性質を事前に定義し、
それらを満たさない変更を機械的に遮断する。

本ドキュメントで言う「レール」とは、
この固定化の条件をシステムの外側から定義する装置を指す。

レールは、良い出力を信頼するためのものではない。
悪い枝が固定化されないことを保証するための構造である。

# 2

ここで扱っている二つの仕組み、すなわち
「探索の範囲を制限すること」と「探索の結果を選別すること」は、
役割が異なるため、本ドキュメントでは意識的に区別して扱う。

探索の範囲を制限する設計要素は、探索が行われる前に存在する。
それらは、探索主体がどの方向に枝を伸ばせるかをあらかじめ規定し、
到達してほしくない領域を探索空間から除外する役割を担う。

一方で、探索の結果を選別する設計要素は、探索が行われた後に作用する。
探索によって生成された枝のうち、
固定化してよいものと、固定化してはいけないものを分ける役割を担う。

この二つは同一のものではないため、
本ドキュメントではレールを次の二つの要素に分けて扱う。

第一に、探索空間の制約である。
これは、実装が生成される前提として、
どの方向に探索が進んでよいかを定める。

第二に、固定化の条件である。
これは、生成された実装や変更が、
統合されてよいかどうかを判断する基準である。

以降では、この二つの観点をもとに、
探索空間の制約として何を先に決めておくべきか、
固定化の条件として何を検証可能な形で定義すべきか、
そしてそれらをどこで検証するかを整理していく。

このドキュメントの次の仕事は、以上の抽象をさらに一段だけ具体化して、「境界」「ドメイン」「アーキテクチャ」それぞれについて、探索空間の制約として何を外部化するか、固定化の条件として何を定義するか、検証地点として何を置くか、を列挙できる形にすることである。

ここで言う「列挙」とは、たとえば次のように、同じ対象を三つの観点に割り当てて書くことを指す。

例として、API のエラー表現を考える。
エラー表現は境界に現れるため、「境界（契約）」として固定されるべき対象になる。したがって、

探索空間の制約：エラーのレスポンス形式（フィールド構造）を固定する

固定化の条件：実装がその形式を破っていないこと（互換性違反がないこと）

検証地点：CI で契約検証（スキーマ検証や互換性チェック）を行う

同じように、ドメインの不変条件を考える。
たとえば「ある状態ではこの操作を許さない」という条件は、実装手順ではなく性質として固定化されるべき対象になる。したがって、

探索空間の制約：状態遷移や権限判定がドメイン（またはドメインに近い層）に集約されるように構造を決める

固定化の条件：禁止された操作が成功しないこと（不変条件が破れないこと）

検証地点：テストでその禁止条件を検証する

このように、対象を「探索の前提」「固定化の条件」「検証地点」に割り当てることで、レールが「何となく気をつけること」ではなく、実装と検証に落ちた具体的な形として記述できる。

# 3

次に行うのは、対象を三つの観点――探索空間の制約／固定化の条件／検証地点――へ割り当てる作業である。ここでは、どのアプリでも必ず現れる対象から始める。題材固有の仕様は後で足せるが、ここで作る骨格は題材が変わっても残る。

まず境界（HTTP API）について考える。境界は外部に露出するため、探索の結果がそのまま外部契約の差分になる領域である。したがって境界では、探索空間の制約は「外形を固定する」という形を取り、固定化の条件は「外形を破っていないこと」という形を取り、検証地点は「統合前に機械的に判定できること」という形を取る。

例として、APIのエラー表現を考える。エラー表現は外形であり、実装詳細ではない。したがって、探索空間の制約としては、エラーレスポンスの形式（フィールド構造と最低限の分類）を固定する。固定化の条件としては、実装がその形式を破らないこと、そして既存の意味を変えないこと（互換性の維持）を置く。検証地点としては、CIにおいてスキーマ検証や互換性チェックを行い、違反した変更が統合されないようにする。

同様に、成功時のレスポンス構造も境界の外形である。探索空間の制約としては、レスポンスのスキーマを固定する。固定化の条件としては、既存クライアントが期待しているフィールドの削除や型変更を行っていないことを置く。検証地点としては、契約検証と回帰テストによって、統合前に差分を検出する。

ここまでで境界の論理は一段落する。境界は「外形が固定される」領域であり、探索は内側で許容される。この区切りが曖昧だと、探索結果が外部契約の差分として固定化されてしまう。したがって、境界に関しては「契約として固定し、契約として検証する」という形でレールを敷くことになる。

次にドメインについて考える。ドメインは外形ではなく意味の領域であり、探索の結果が「ビジネス上許されない状態」を作る枝を生みうる。ここで固定されるべきなのは処理手順ではなく、到達してよい状態と到達してはいけない状態の区別である。したがってドメインでは、探索空間の制約は「意味が集約される場所を決める」という形を取り、固定化の条件は「禁止された結果に到達しないこと」という形を取り、検証地点は「禁止条件を落とすテスト」という形を取る。

例として、状態が存在する対象を考える。たとえば、何らかの“申請”“投稿”“注文”“タスク”のように、作成され、更新され、ある時点で確定する対象である。ここで一般に問題になるのは、「確定後に変更してよいのか」「ある状態で実行してよい操作は何か」といった条件である。これらは実装手順ではなく性質であり、探索がどれだけ多分岐しても維持されるべき対象になる。したがって、探索空間の制約としては、状態遷移や権限判定がドメイン（またはドメインに近い層）に集約されるように構造を決める。固定化の条件としては、禁止された操作が成功しないこと、禁止された遷移が起きないことを置く。検証地点としては、その禁止条件をテストで表現し、統合前に落とす。

ドメインではもう一つ、整合性の条件が現れる。たとえば「同じキーは重複できない」「関連する値が揃っていなければならない」といった条件である。これも性質であり、探索の結果として破られてはならない。探索空間の制約としては、整合性に関わる判断が散らばらず、一箇所で行われるように設計する。固定化の条件としては、整合性が破れる入力や状態の組が成功しないことを置く。検証地点としては、テストと、必要ならDB制約のような二重化された検証を置く。

最後にアーキテクチャについて考える。アーキテクチャは、境界やドメインで定義した制約・条件が実装として維持されるように、探索空間の地形を作る領域である。ここでの探索空間の制約は、関心事が混線しないように構造を決めることになる。固定化の条件は、その構造が破られていないことになる。検証地点は、構造違反を統合前に検出できる場所になる。

例として、依存方向を考える。ドメインが外部I/Oに直接触れ始めると、ドメインの性質は実装都合に侵食されやすくなる。これは「良い／悪い」ではなく、ここまで述べたレール（契約・不変条件）を維持するための都合である。したがって探索空間の制約としては、外部I/Oは境界とインフラ層に閉じ、ドメインはそれに依存しない、という依存方向を置く。固定化の条件としては、その依存方向が破られていないことを置く。検証地点としては、静的解析やimportルール、パッケージ構造の検査をCIに組み込み、違反が統合されないようにする。

ここまでで、境界・ドメイン・アーキテクチャの三観点について、対象を「探索空間の制約／固定化の条件／検証地点」に割り当てるという操作が可能になった。次の段階では、この割り当てを、実際に採用する技術要素――たとえばOpenAPI、型、テスト、CI、静的解析、リポジトリ構造――に接続し、どの検証地点で何を判定するかを、実装可能な手続きとして記述する。