# AI協業開発におけるレール設計（草案）
*更新日: 2026-02-03*

## TL;DR
AIを「一貫した判断主体」として信頼するのではなく、曖昧さを含む文脈から次の一手を生成する**確率的な生成過程**として扱う。

失敗モードは「不適切な枝が統合され、以降の前提として固定化されること」であり、対策は**探索（生成）と固定（統合）の分離**にある。

この分離を成立させる装置が本ドキュメントで言う「レール」で、レールは (1) 探索空間の制約（どこまで自由にしてよいか）と、(2) 固定化の条件（何を満たしたら統合してよいか）に分解して扱う。

固定化の関所（CI）は少なくとも「境界（契約）」「ドメイン（性質）」「アーキテクチャ（構造）」の三種類の違反を落とす必要がある。

以降では、境界の一次情報（OpenAPI）とその更新の扱い、ドメイン不変条件の外部化（テスト化）の粒度、構造制約の静的検査化を、リポジトリ上の成果物とCI手続きとして閉じる形まで落としていく。

## 目次
- 1. 設計方針：確率的な生成過程を開発系に入れたときの安定化条件
- 2. レールの分解：探索空間の制約と固定化の条件
- 3. 三観点（境界・ドメイン・アーキテクチャ）への割り当て
- 4. レールを「成果物」として扱う
- 5. 技術選定と日々の運用への接続
- 6. リポジトリとCIに落とすための前提整理
- 7. 境界の契約更新とドメイン不変条件を「検証に落とせる形」へ
- 8. ファイル配置とCIの検証順序
- 9. 移行定義と境界テストを成果物として閉じる
- 10. Goバックエンド／TSフロントエンドでの具体化例
- 付録：後回し

## 1. 設計方針：確率的な生成過程を開発系に入れたときの安定化条件

### 1.1 AIを「知識主体」ではなく生成過程として扱う

本設計では、AIを「知識を保持し一貫した判断を行う主体」としてではなく、
読み込んだ文脈に条件づけられて、確率的に次の一手を生成する生成過程として扱う。

以降、便宜上AIを「探索主体」と呼ぶ箇所があるが、主体性（目的を持った探索）を仮定する意図はない。
本書における「探索」とは、出力が多分岐になりうる生成過程を、開発プロセス上そう取り扱う、という意味である。

曖昧さを含む文脈を入力とする限り、AIの出力は本質的に多分岐になる。
それぞれの出力は局所的にはもっともらしく見えるが、そのすべてがシステム全体にとって適切であるとは限らない。

したがって、AIを開発に導入することは
「実装を自動化する」ことではなく、
実装の探索が高速かつ多分岐になる状況を受け入れることを意味する。

### 1.2 失敗モード：不適切な枝の固定化

問題は、探索によって不適切な枝が生成されること自体ではない。
問題になるのは、不適切な枝がそのまま統合され、
以降の開発における前提として固定化されてしまうことである。

### 1.3 安定化の定義

この観点から見ると、本設計が扱う課題は
「確率的な生成過程を開発系に入れたときの安定化条件」になる。

ここで言う安定化とは、
探索（生成）が継続しても、システムが持つべき性質が崩れないことを指す。
言い換えれば、

探索（生成）と固定（統合）が分離され、
固定されるのは検証を通過したものだけ、
という構造を作ること
である。

この構造を成立させるためには、二つの仕組みが必要になる。

### 1.4 探索空間の制約

一つは、探索の範囲をあらかじめ制限することだ。
アーキテクチャ、境界、責務分離、依存方向といった設計要素は、
AIに正解を教えるためのものではなく、
探索が向かってよい方向と、向かってはいけない方向を定めるためのものとして機能する。

### 1.5 固定化の条件

もう一つは、探索の結果を選別することだ。
生成された実装や変更のうち、
設計として許容できないものが統合されるのを防ぐ必要がある。
そのために、契約、不変条件、互換性といった性質を事前に定義し、
それらを満たさない変更を機械的に遮断する。

### 1.6 レールの定義

本ドキュメントで言う「レール」とは、
この固定化の条件をシステムの外側から定義する装置を指す。

レールは、良い出力を信頼するためのものではない。
悪い枝が固定化されないことを保証するための構造である。

## 2. レールの分解：探索空間の制約と固定化の条件

### 2.1 二つの仕組みを区別する

ここで扱っている二つの仕組み、すなわち
「探索の範囲を制限すること」と「探索の結果を選別すること」は、
役割が異なるため、本ドキュメントでは意識的に区別して扱う。

探索の範囲を制限する設計要素は、探索が行われる前に存在する。
それらは、探索主体がどの方向に枝を伸ばせるかをあらかじめ規定し、
到達してほしくない領域を探索空間から除外する役割を担う。

一方で、探索の結果を選別する設計要素は、探索が行われた後に作用する。
探索によって生成された枝のうち、
固定化してよいものと、固定化してはいけないものを分ける役割を担う。

### 2.2 レールを二要素に分ける

この二つは同一のものではないため、
本ドキュメントではレールを次の二つの要素に分けて扱う。

第一に、探索空間の制約である。
これは、実装が生成される前提として、
どの方向に探索が進んでよいかを定める。

第二に、固定化の条件である。
これは、生成された実装や変更が、
統合されてよいかどうかを判断する基準である。

なお、現実の仕組みはこの二要素にきれいに分離できないことがある。
たとえば依存方向のルールは、事前に「越境してはいけない」を宣言して探索方向を狭めると同時に、事後にCIで違反を落とす判定にもなる。
本ドキュメントでの分類は排他的なラベルではなく、各成果物や検査を「事前の誘導」と「事後の選別」のどちらに主として接続するかを明確にするための整理である。

以降では、この二つの観点をもとに、
探索空間の制約として何を先に決めておくべきか、
固定化の条件として何を検証可能な形で定義すべきか、
そしてそれらをどこで検証するかを整理していく。

### 2.3 列挙と分類は「設計の操作」になる

このドキュメントの次の仕事は、以上の抽象をさらに一段だけ具体化して、「境界」「ドメイン」「アーキテクチャ」それぞれについて、探索空間の制約として何を外部化するか、固定化の条件として何を定義するか、検証地点として何を置くか、を列挙できる形にすることである。

ここで言う「列挙」とは、たとえば次のように、同じ対象を三つの観点に割り当てて書くことを指す。

### 2.4 例：境界のエラー表現を分類する

例として、API のエラー表現を考える。
エラー表現は境界に現れるため、「境界（契約）」として固定されるべき対象になる。したがって、

探索空間の制約：エラーのレスポンス形式（フィールド構造）を固定する

固定化の条件：実装がその形式を破っていないこと（互換性違反がないこと）

検証地点：CI で契約検証（スキーマ検証や互換性チェック）を行う

### 2.5 例：成功レスポンスの扱いを分類する

同じように、ドメインの不変条件を考える。
たとえば「ある状態ではこの操作を許さない」という条件は、実装手順ではなく性質として固定化されるべき対象になる。したがって、

探索空間の制約：状態遷移や権限判定がドメイン（またはドメインに近い層）に集約されるように構造を決める

固定化の条件：禁止された操作が成功しないこと（不変条件が破れないこと）

検証地点：テストでその禁止条件を検証する

### 2.6 まとめ：箇条書きが意味を持つ条件

このように、対象を「探索の前提」「固定化の条件」「検証地点」に割り当てることで、レールが「何となく気をつけること」ではなく、実装と検証に落ちた具体的な形として記述できる。

## 3. 三観点（境界・ドメイン・アーキテクチャ）への割り当て

### 3.1 題材に依存しない骨格を作る

次に行うのは、対象を三つの観点――探索空間の制約／固定化の条件／検証地点――へ割り当てる作業である。ここでは、どのアプリでも必ず現れる対象から始める。題材固有の仕様は後で足せるが、ここで作る骨格は題材が変わっても残る。

### 3.2 境界：外形（契約）を固定する

まず境界（HTTP API）について考える。境界は外部に露出するため、探索の結果がそのまま外部契約の差分になる領域である。したがって境界では、探索空間の制約は「外形を固定する」という形を取り、固定化の条件は「外形を破っていないこと」という形を取り、検証地点は「統合前に機械的に判定できること」という形を取る。

例として、APIのエラー表現を考える。エラー表現は外形であり、実装詳細ではない。したがって、探索空間の制約としては、エラーレスポンスの形式（フィールド構造と最低限の分類）を固定する。固定化の条件としては、実装がその形式を破らないこと、そして既存の意味を変えないこと（互換性の維持）を置く。検証地点としては、CIにおいてスキーマ検証や互換性チェックを行い、違反した変更が統合されないようにする。

同様に、成功時のレスポンス構造も境界の外形である。探索空間の制約としては、レスポンスのスキーマを固定する。固定化の条件としては、既存クライアントが期待しているフィールドの削除や型変更を行っていないことを置く。検証地点としては、契約検証と回帰テストによって、統合前に差分を検出する。

ここまでで境界の論理は一段落する。境界は「外形が固定される」領域であり、探索は内側で許容される。この区切りが曖昧だと、探索結果が外部契約の差分として固定化されてしまう。したがって、境界に関しては「契約として固定し、契約として検証する」という形でレールを敷くことになる。

### 3.3 ドメイン：性質（不変条件）を固定する

次にドメインについて考える。ドメインは外形ではなく意味の領域であり、探索の結果が「ビジネス上許されない状態」を作る枝を生みうる。ここで固定されるべきなのは処理手順ではなく、到達してよい状態と到達してはいけない状態の区別である。したがってドメインでは、探索空間の制約は「意味が集約される場所を決める」という形を取り、固定化の条件は「禁止された結果に到達しないこと」という形を取り、検証地点は「禁止条件を落とすテスト」という形を取る。

例として、状態が存在する対象を考える。たとえば、何らかの“申請”“投稿”“注文”“タスク”のように、作成され、更新され、ある時点で確定する対象である。ここで一般に問題になるのは、「確定後に変更してよいのか」「ある状態で実行してよい操作は何か」といった条件である。これらは実装手順ではなく性質であり、探索がどれだけ多分岐しても維持されるべき対象になる。したがって、探索空間の制約としては、状態遷移や権限判定がドメイン（またはドメインに近い層）に集約されるように構造を決める。固定化の条件としては、禁止された操作が成功しないこと、禁止された遷移が起きないことを置く。検証地点としては、その禁止条件をテストで表現し、統合前に落とす。

ドメインではもう一つ、整合性の条件が現れる。たとえば「同じキーは重複できない」「関連する値が揃っていなければならない」といった条件である。これも性質であり、探索の結果として破られてはならない。探索空間の制約としては、整合性に関わる判断が散らばらず、一箇所で行われるように設計する。固定化の条件としては、整合性が破れる入力や状態の組が成功しないことを置く。検証地点としては、テストと、必要ならDB制約のような二重化された検証を置く。

### 3.4 アーキテクチャ：構造（依存方向）を固定する

最後にアーキテクチャについて考える。アーキテクチャは、境界やドメインで定義した制約・条件が実装として維持されるように、探索空間の地形を作る領域である。ここでの探索空間の制約は、関心事が混線しないように構造を決めることになる。固定化の条件は、その構造が破られていないことになる。検証地点は、構造違反を統合前に検出できる場所になる。

例として、依存方向を考える。ドメインが外部I/Oに直接触れ始めると、ドメインの性質は実装都合に侵食されやすくなる。これは「良い／悪い」ではなく、ここまで述べたレール（契約・不変条件）を維持するための都合である。したがって探索空間の制約としては、外部I/Oは境界とインフラ層に閉じ、ドメインはそれに依存しない、という依存方向を置く。固定化の条件としては、その依存方向が破られていないことを置く。検証地点としては、静的解析やimportルール、パッケージ構造の検査をCIに組み込み、違反が統合されないようにする。

### 3.5 次の段階：技術と運用へ落とす

ここまでで、境界・ドメイン・アーキテクチャの三観点について、対象を「探索空間の制約／固定化の条件／検証地点」に割り当てるという操作が可能になった。次の段階では、この割り当てを、実際に採用する技術要素――たとえばOpenAPI、型、テスト、CI、静的解析、リポジトリ構造――に接続し、どの検証地点で何を判定するかを、実装可能な手続きとして記述する。

## 4. レールを「成果物」として扱う

### 4.1 レールは差分として観測できる必要がある

前段の割り当てを「実装可能な手続き」に落とすとき、まず確認すべきことがある。ここでいうレールは概念として語るだけではなく、リポジトリの中に置かれ、CIの中で実行され、統合の可否を決める“物”である。したがって「境界・ドメイン・アーキテクチャ」という観点で割り当てたものは、それぞれ対応する成果物（仕様ファイル、テスト、静的検査、差分検査）に接続されなければならない。固定化の条件が外側から定義される、というのは結局、「統合してよいか」を判定する入力がコードの外側に存在し、その入力に照らして機械的に落とされる、という形になる。

### 4.2 境界：契約を一次情報として固定する

境界の契約を“物”にする最短経路は、OpenAPIのような機械可読な仕様を単一の参照点として持つことだ。境界で固定したいのは外形であり、外形は差分として検出できる形を取る必要がある。OpenAPIがリポジトリの中にあり、それをもとにサーバ側の型やインターフェース、クライアント側の型が生成されるなら、探索主体が内部実装をどういじっても外形はそこから逸れにくくなる。さらに固定化の条件として「互換性違反がない」を置くなら、統合前にOpenAPI差分を比較して破壊的変更を検出する手続きが成立する。ここで重要なのは「互換性を守れ」という気持ちではなく、「互換性違反の形」を定義して差分で落とすことだ。そうすると、境界のレールは「仕様ファイル＋差分検査＋型生成」という組として具体化される。

### 4.3 ドメイン：性質をテストとして外部化する

ドメイン側は逆で、仕様ファイルだけでは十分にならない。ドメインで固定したいのは外形ではなく性質であり、性質はコード上の振る舞いとしてしか現れないからだ。ここで固定化の条件を“物”にする中心はテストになる。テストは「こう実装せよ」ではなく、「この結果に到達してはいけない」「この条件は常に満たされる」という禁止・保証の表現になる。探索主体に実装を委ねるならなおさら、固定化の条件は先に書かれている必要がある。言い換えると、TDDはこの文脈では単なる開発流儀ではなく、「固定化の条件を先に外部化する」ための手続きとして意味を持つ。実装を探索させる前に、落としてはいけない性質をテストとして先に置くことで、探索の結果が統合される条件が外側から与えられる。

### 4.4 アーキテクチャ：構造制約を静的検査として固定する

アーキテクチャについては、構造そのものを“物”にする必要がある。責務分離や依存方向は、ドキュメントで宣言しただけでは固定化の条件にならない。探索主体が複数の枝を生むなら、層の越境や依存の逆流もまた枝として自然に生まれる。ここで必要なのは「この層からこの層へ依存してよい／いけない」を機械が判定できる形にすることだ。Goならパッケージ構造そのものが制約になるし、静的解析やlintのルールとして「禁止されたimport」を落とすこともできる。TypeScriptでも同様に、モジュール境界とimport規則を検査対象にできる。こうしてアーキテクチャのレールは「ディレクトリ構造＋依存ルール＋静的検査」という組として具体化される。

### 4.5 CI：固定化の関所として統合する

ここまでをまとめると、レールは三種類の検証として現れる。境界は契約差分として検証され、ドメインは性質テストとして検証され、アーキテクチャは構造検査として検証される。そして「固定化」は、これらをすべて通過した変更だけに許される。実務上の固定化の単位は、多くの場合PRのマージであり、マージが“前提の更新”になる。だから検証地点は最終的にCIに集約される。もちろんローカルでも回せるが、固定化を許すかどうかの判定は、誰が実行しても同じ結果になる地点に置く必要がある。

### 4.6 規模拡大時に狙うこと

この配置は、アプリが小さい間は過剰に見えるかもしれない。しかし、ここまでの論理が狙っているのは「小さい間にうまくいくこと」ではなく、「探索が高速・多分岐になっても前提が汚染されないこと」だ。規模が上がるほど、固定化の条件は増える。だが増やすべきものは無秩序なルールではなく、境界・ドメイン・アーキテクチャのいずれかに属する“検証可能な条件”である。そうして条件が増えても、構造は変わらない。探索空間の制約を与え、固定化の条件を定義し、検証地点で落とす――この型を保ったまま、対象が増えていくだけになる。

### 4.7 次の課題：技術と運用へ落とす

次に書くべきことは、この「三種類の検証」を、実際の技術選定とリポジトリ運用に接続することである。すなわち、どの成果物を単一参照点にするか（たとえばOpenAPI）、どの性質をテストとして外部化するか（不変条件の表現）、どの構造を静的に落とすか（依存方向の検査）、そしてそれらをCIのどの段階で走らせ、落ちたときに何が起きるか（統合されない、という事実）を、手続きとして書き下す。

## 5. 技術選定と日々の運用への接続

### 5.1 導出の対象と立場

次に必要なのは、ここまでを「技術選定」と「日々の運用」に落とすことである。レールが“物”である以上、どの成果物を一次情報として扱い、どの順序で検証を走らせ、失敗したときにどう振る舞うかが、設計の一部になる。ここでは、個別技術の紹介ではなく、なぜその技術がこの型に接続されるのか、という導出に集中する。

### 5.2 境界：OpenAPIを契約の一次情報にする

境界に関しては、OpenAPIを契約の一次情報として扱うのが自然である。境界で固定したいのは外形であり、外形は人間の説明文ではなく差分として検出できる必要がある。OpenAPIは外形を機械可読な形で固定でき、かつ差分比較によって契約の変化を検出できる。したがって境界のレールは、(1) OpenAPIを単一参照点として置き、(2) そこから型やクライアントを生成することで探索主体の自由度を境界の内側へ押し込み、(3) CIで契約検証と差分検査を走らせて契約に反する変更が固定化されないようにする、という手続きとして構成される。この手続きの利点は、実装者の注意力ではなく「差分」を根拠に固定化可否を決められる点にある。

### 5.3 OpenAPIを一次情報にしたときに生まれる論点

ただし、OpenAPIを単一参照点にすると決めた瞬間から、別の論点が生まれる。OpenAPIが変わるということは、内部実装が変わるのではなく、外部に対する約束が変わるということである。ここでは変更を「実装変更」と「契約更新（仕様更新）」に分けて扱う。実装変更とは、OpenAPIで表現される外形を変えずに内部実装を変える変更である。一方、契約更新とは、外から見た約束そのものを変える変更であり、具体的にはリクエスト／レスポンスのスキーマ変更（フィールド追加・削除、型変更、required/optionalの変更、バリデーション制約の変更）、エンドポイントの変更（パス、HTTPメソッド、クエリの意味）、エラー表現の変更（構造、分類、エラーコード体系、同一条件で返るステータス）、認証・認可の前提変更などが該当する。

契約更新を扱うときに中心になるのが互換性である。本ドキュメントで言う互換性とは原則として後方互換性を指し、既存のクライアントがコード変更なしで動き続けることを意味する。後方互換性を破る変更（破壊的変更）とは、例えば既存フィールドの削除、型変更、必須化、エンドポイントの削除や変更、エラーの意味変更など、既存クライアントの前提を壊す変更である。したがって契約更新を固定化するには、「差分として何が変わったか」だけでなく、「その差分が後方互換性を破っているか」を判定できる必要がある。

さらに、破壊的変更を伴う契約更新には移行が必要になる。ここで言う移行とは、契約変更に追従するための手順であり、利用側（フロントエンドや他サービス）が壊れずに追従できるようにする措置を指す。典型的には、(a) 後方互換を保ったまま段階移行する（新仕様を追加し旧仕様を一定期間残し、移行完了後に旧仕様を廃止する）、(b) バージョニングで並行稼働する（v1とv2を併存させ、期限を決めて旧版を終了する）、(c) 利用側と同時リリースできる範囲に限って即時変更する、のいずれかになる。移行が定義されない破壊的変更は、固定化される前提として扱えない。

### 5.4 「探索と固定の分離」を一次情報にも適用する

ここで言いたいのは運用の厳格さではない。「探索と固定の分離」を境界の一次情報にも適用する、という一貫性である。探索主体は契約に合わせて実装を探索することはできるが、契約そのものを探索結果として揺らがせてはならない。OpenAPIを変更する行為は探索ではなく設計判断として扱い、契約更新は互換性と移行を含む固定化の条件を満たしたときだけ統合される、という構造を境界にも適用する。

### 5.5 ドメイン：性質テストで固定化を成立させる

ドメインについては、テストを固定化の条件として置く、という方針が具体的な設計に変換される。ここで重要なのは、テストが「実装の正しさを証明する」ためにあるのではなく、「固定してはいけない枝」を統合前に落とすための装置として使われる、という位置づけである。テストの記述対象は、理想的には“やり方”ではなく“性質”である。禁止された状態遷移、成立してはいけない組み合わせ、権限違反、整合性違反といったものは、探索主体がどう実装しても変わってはいけない。したがって、それらを先にテストとして外部化し、探索結果をそのテストに通すことで、固定化の条件が手続きとして成立する。

このとき、ユニットテストだけに寄せる必要はない。境界の契約とドメインの不変条件は、しばしば統合点で破れる。だから、性質を表現するテストは層を跨ぐ形になることがある。ここで重要なのは「どの粒度のテストが正しいか」ではなく、「固定化の条件として必要な性質が表現されているか」である。探索主体に委ねる自由度が大きいほど、固定化の条件は抽象度の高い性質として表現され、テストはその性質に対する反例を潰す形になる。

なお、同じ性質が境界テストとドメインテストの両方で検証されることがある。
たとえば「権限がない操作は拒否される」は、境界では 403 として観測され、ドメインでは越権が状態を変化させない不変条件として表現できる。
ここでは重複を避けることが目的ではなく、境界テストは「利用側が観測する分類・前提」を固定し、ドメインテストは「内部状態を汚染しない性質」を固定する、という観点差を保つことが重要になる。


### 5.6 テスト粒度は固定化条件としての必要性で決める

アーキテクチャについては、静的検査の導入が最も直接的にレールへ接続される。依存方向や層の越境は、探索主体が局所的な都合で踏み抜きやすい。だから、構造の固定化条件は、コードレビューで気づく前に機械的に落とせる形にするのが望ましい。Goならパッケージ構造とimport制約がこの役割を担えるし、TypeScriptでもモジュール境界とimport規則を検査対象にできる。ここでの静的検査は、スタイルを揃えるためではなく、探索空間の制約が破られていないことを判定するための装置になる。

### 5.7 アーキテクチャ：静的検査で越境を落とす

以上を踏まえると、CIは単なる自動テストの実行環境ではなく、固定化の関所として設計される。CIの各段階は、それぞれ別の種類の違反を落とす。境界は契約差分として落とし、ドメインは性質テストとして落とし、アーキテクチャは構造検査として落とす。重要なのは順序ではなく、固定化可否がこの三種類の判定に従属する、という関係を明示することだ。

### 5.8 CIは固定化の関所として設計される

この構造を日々の開発に落とすと、作業単位は自然に「探索」と「固定化準備」に分かれる。探索主体に実装を生成させるフェーズでは、人間は意図を言語化し、レールに従う形に誘導する。AIの出力が多分岐になること自体は前提として受け入れつつ、まずは一つの実装案を生成させる。その案が固定化の条件を満たすかを検証し、満たさなければ修正または再生成によって枝を切り落とす。一方で固定化準備のフェーズでは、人間は候補をレールに照らして切り落とし、必要ならレール側（契約・不変条件・依存制約）を補強し、再び探索へ戻す。

### 5.9 日々の作業単位と次に落とすべき規則

次に記述すべきは、この往復運動を壊さないために、リポジトリの中にどの成果物を置くか、そしてそれらをどう変更するかの規則である。すなわち、契約はどこに置かれ、テストはどの層に配置され、依存方向のルールはどの形で宣言され、CIはそれらをどう参照し、変更が失敗したときにどの地点で止まるのか。ここまで落とせれば、本設計はリポジトリ上の成果物とCI上の検証手続きとして記述が閉じる。

## 6. リポジトリとCIに落とすための前提整理

### 6.1 一次情報と検証入力を区別する

固定化の条件を外側から与える、という方針を実装手続きとして成立させるには、リポジトリ内の成果物を「一次情報」と「検証に使う入力」に分解し、その関係が崩れないように配置と変更規則を定める必要がある。一次情報とは、境界・ドメイン・アーキテクチャのうち「固定されるべきもの」を表現する参照点であり、検証に使う入力とは、一次情報に照らして統合可否を判定するための材料である。ここを曖昧にすると、固定化の条件がコードの内側へ回収され、検証が「実装の都合」に引きずられやすくなる。

境界の一次情報は OpenAPI に置く。重要なのは形式そのものではなく、外形が単一の参照点としてリポジトリに存在し、差分として比較できることである。したがって、OpenAPI のファイルは「コード生成の入力」であると同時に「差分検査の入力」でもある、という二重の位置づけを持つ。この二重性を崩さないために、境界に関する実装変更は OpenAPI に従属し、OpenAPI の変更は設計判断として扱われる、という関係を規則として固定する。

### 6.2 三種類の違反と静的検査の位置づけ

ドメインの一次情報は、OpenAPI のような単一ファイルに収束しない。ここで固定したいのは外形ではなく性質であり、性質は最終的に「反例を落とす検証」としてしか外側に出せない。したがってドメインについては、一次情報を「不変条件の言語化（ドキュメント）」として置くのではなく、固定化の条件そのものを「テスト（検証コード）」として置く方が一貫する。ドメインの不変条件は、実装の“やり方”から独立した形でテストに表現され、CI はそれを固定化の関所として参照する。このとき、テストは「実装を説明する文書」ではなく「統合の可否を判定する入力」である。

アーキテクチャの一次情報は、パッケージ構造と依存規則に置く。ここでの一次情報は「層構造の説明」ではなく、越境や逆流が起きたときに機械的に検出できる形であることが要件になる。したがって、ディレクトリ／パッケージ境界が探索空間の地形として機能し、依存規則は静的検査の入力として機能するように設計する。言い換えると、アーキテクチャの一次情報は、主に「配置」と「禁止関係」の形で外部化される。

以上を踏まえると、リポジトリの配置は次の性質を満たすべきになる。第一に、境界の一次情報（OpenAPI）が一箇所にあり、生成と差分検査の双方から参照されること。第二に、ドメインの固定化の条件（テスト）が、境界やインフラの都合に引きずられない配置になっていること。第三に、アーキテクチャの制約（パッケージ／モジュール境界）が、禁止された依存を検出できる形になっていること。具体のツリーはプロジェクト事情で変わるが、少なくとも次のような“参照関係”だけは固定する、という方針になる。

### 6.3 境界：契約更新の条件が先に要る

```
/api/
  openapi.yaml            # 境界の一次情報（契約の参照点）

/backend/                 # Go
  /cmd/ ...
  /internal/
    /domain/              # ドメイン（不変条件の中心）
    /usecase/             # アプリケーション層
    /infra/               # DB/外部I/O
    /transport/           # HTTP（openapiに従属）
  /tests/                 # 性質の検証（固定化の条件）

### 6.4 ドメイン：不変条件の外部化の線引きが要る

/frontend/                # TypeScript
  ...                     # APIクライアントは openapi から生成・参照

/.github/workflows/       # 固定化の関所としてのCI
```

### 6.5 次に詰める論点が二つに整理できる理由

次に、変更規則である。ここで決めるべきなのは「誰が変更できるか」ではなく、「変更が固定化される条件が何に依存するか」である。境界については、OpenAPI を変更するPRはそれ自体が契約更新なので、少なくとも「互換性の扱い」と「移行の扱い」が示されていない限り固定化されない、という条件を置ける。これは文書レビューの話ではなく、CI の入力を揃える話である。たとえば、OpenAPI の差分検査が破壊的変更を検出した場合、そのまま落ちるか、あるいは「バージョニング」「段階移行」のどちらかが選択されていることを機械的に確認できる入力が必要になる。段階移行なら、旧仕様が残っていることと廃止までの方針が示されること、バージョニングなら v1 と v2 が並行稼働できる形になっていることが、固定化の条件になる。

ドメインについては、固定化の条件はテストの形で増えていく。ここでのルールは、テストを増やすこと自体ではなく、「不変条件が実装の説明ではなく統合の条件として追加される」という関係を崩さないことにある。すなわち、実装を変えた結果としてテストを追従させるのではなく、許されない枝を落とすためにテストを追加し、その上で実装を探索させる、という順序を守る。これにより、固定化の条件が実装に従属するのを避けられる。

アーキテクチャについては、依存規則を“宣言”として持つか、“構造”として持つかの違いがある。構造（パッケージ境界）で持てる部分は構造で持つべきであり、宣言（lint設定や独自ルール）でしか表現できない部分だけを宣言で補う。ここでも重要なのは美学ではなく、探索主体が局所的に越境した枝を固定化しないために、違反が機械的に検出される状態を維持することである。

最後に、CIにおける「どの地点で止まるか」を明示する。固定化の関所としてのCIは、少なくとも三種類の判定を持つ。第一に境界の判定で、OpenAPIに対する検証（生成が可能であること、スキーマが整合していること、互換性違反がないこと）を行う。第二にドメインの判定で、性質テストが通ることを確認する。第三にアーキテクチャの判定で、依存方向や越境が起きていないことを静的に確認する。これらのいずれかが失敗した変更は統合されない、という一点だけが固定されれば、探索の過程がどれだけ揺れても「固定されるのは検証を通過したものだけ」という構造は崩れない。

まず、この文章が扱っている失敗モードは「不適切な枝が固定化され、以降の前提が汚染されること」だった。これを防ぐには、固定化の関所（CI）が、少なくとも次の三種類の違反を落とす必要がある、という整理をすでに置いた。第一に境界であり、外部契約の違反（契約差分・互換性違反）を落とす。第二にドメインであり、性質の違反（不変条件の破れ）を落とす。第三にアーキテクチャであり、構造の違反（依存方向・越境）を落とす。

このうちアーキテクチャの違反は、静的検査／構造検査という形式に落ちやすく、何をすればよいかが比較的明確である。禁止された import や層越境、依存方向の逆流といった違反を、機械的に検出して落とす、という形にしやすい。一方で境界とドメインは、「何を固定し、どこまでを破ってはいけないと見なすか」という裁定が先に必要になる。ここが曖昧なままだと、検証は存在しても判定基準が定まらず、固定化の条件として機能しない。

境界では、契約更新をどこまで許すかを決めないと、差分検査が「落とすべき差分」と「許容する差分」を区別できない。破壊的変更を許すなら移行やバージョニングが要るし、それらをどこまで機械的に扱うかによって、固定化の条件の形が決まる。

ドメインでは、不変条件をどの粒度でテストとして外部化するかを決めないと、固定化の条件が増えない。すなわち、枝を切る基準が増えない。逆に無秩序に増やすと、テストが過剰拘束になりやすい。だから「どこまでを固定化条件として明文化するか」という線引きが必要になる。

以上を踏まえると、この段階まで来たときに次に詰める論点は、大きく二つに整理できる。ひとつは、境界の契約更新をどの条件で許容するか（互換性・移行・バージョニングをどこまで機械化するか）。もうひとつは、ドメインの不変条件をどの粒度でテストとして外部化するか（どこまでを固定化の条件として増やすか）。以降は、この二点を先に決める方針で進める。その上で、必要な技術（生成、差分検査、静的検査、テストの配置）を逆算して具体化していく。

## 7. 境界の契約更新とドメイン不変条件を「検証に落とせる形」へ

### 7.1 固定化の条件を先に決める、という意味

以上の二点を詰める、というのは「技術を選ぶ」より先に、「何を固定化の条件として扱うか」を決める、という意味になる。ここで固定化の条件が曖昧だと、検証は存在しても、何を落とし何を通すのかが揺れ、結局は人間の気分やその場の文脈に回収される。したがって以降では、境界については「契約更新を許容する条件」を、ドメインについては「不変条件を外部化する粒度」を、それぞれ“検証に落とせる形”まで下ろす。

### 7.2 契約更新は差分として観測される

境界の契約更新について、まず前提を固定する。OpenAPIを一次情報とする以上、境界の変更はOpenAPI差分として観測される。その差分が固定化されるかどうかは、差分の内容が「後方互換性を保っているか」「破壊的変更であるなら移行が定義されているか」に従属させる。これは精神論ではなく、固定化を差分に従属させるという設計上の一貫性である。

このとき契約更新を、少なくとも三種類に分類して扱う必要がある。第一に、後方互換な変更である。典型はレスポンスへのフィールド追加、任意パラメータの追加、エラー表現の拡張などで、既存クライアントが壊れない方向の拡張である。第二に、破壊的変更である。既存フィールドの削除、型変更、必須化、エンドポイントの削除や意味変更など、既存クライアントの前提を壊す変更がこれに当たる。第三に、表面的には後方互換に見えるが外形では検出できない互換性（解釈・分類・運用前提）を破る変更である。

### 7.3 外形では検出できない互換性（解釈・分類・運用前提）

たとえば同じ200でも中身の意味が変わる、同じ入力に対する扱いが変わる、成功・失敗の分類が変わる、といった変更は、スキーマ差分だけでは十分に把握できない。
ここで言う「外形」とは、OpenAPI（およびその差分検査）だけで破壊的かどうかが判定できる要素――HTTPメソッド/パス、構造、型、必須/任意、enum等――を指す。
そして「外形では検出できない互換性」とは、外形が保たれていても、利用側が置いている前提（解釈・分類・運用上の期待）が崩れることを指す。
まず外形化できるものは可能な限りOpenAPIへ押し込み、それでも外形の外側に残る前提だけを境界テストで固定する、という順序になる。
以下はその一部の例であり、網羅を意図しない。

### 7.4 外形では検出できない互換性をテストに落とす具体例

#### 7.4.1 「200の意味が変わる」を固定する

「POST /orders が 200 accepted を返したら、注文は確定している」という前提があるなら、それを観測可能な事後条件にする。

POST /orders で status=accepted が返る。

直後に GET /orders/{id} を叩くと state=confirmed が観測される（あるいは在庫が減っている、など）。

こういう“2リクエストで観測できる性質”に落とすと、意味が変わった瞬間に落ちる。逆に「accepted は非確定でよい」設計に変えるなら、テストもそれに合わせて変える（＝それは仕様変更として扱われる）。

#### 7.4.2 「同じ入力の扱いが変わる」を固定する

GET /users?email=... の未登録時が 404 なのか 200 [] なのかは、まさにクライアント分岐の前提だから、期待する分類をそのままテストに書く。

未登録 email → 404。

登録済 email → 200 + user。

ここは OpenAPI に書けそうに見えるが、実際には「どういう条件でどっちになるか」が外形だけだと曖昧になりがちだから、シナリオで固定するのが確実。

#### 7.4.3 「成功/失敗の分類」を固定する

これは“HTTPの分類を固定するテスト”に落とすのが素直。

存在しないレポートID → 404（失敗扱い）。

権限なし → 403。

バリデーション不正 → 400。

こういうのは OpenAPI にも書けるが、「条件の切り分け」が実装で崩れやすいので、代表ケースをテストで固定しておくと、分類がズレたときに落ちる。

#### 7.4.4 「値集合の意味が変わる」を固定する

currency: string のまま BTC が来て落ちる、みたいなのは二つの対策がある。

可能なら OpenAPI 側を enum にして外形で固定する（差分で検出できる領域に押し込む）。

それが無理なら、境界テストで「返ってよい値集合」を固定する（例: JPY/USD 以外は返さない）。

ここは「意味」というより「ドメイン制約」だから、テストのほうが表現しやすい。

#### 7.4.5 「冪等性・副作用」を固定する

冪等性は同じリクエストを2回投げて観測するしかない。

同一 idempotency-key（または同一入力）で2回 POST /payments/confirm。

課金レコードが1件しか増えない／合計金額が変わらない。

返却レスポンスが同一（または同一視できる）。

これは OpenAPI ではほぼ固定できないので、境界レベルの性質テストとして持つのがレール的に自然。

この第三種を扱うために、境界は「OpenAPIで固定できる外形」と「OpenAPIの外側にある前提」の二層で固定化される必要がある。

### 7.5 破壊的変更における移行という固定化条件

したがって本設計における運用は次の形になる。後方互換な変更は、OpenAPI差分検査で破壊的変更が検出されない限り、通常の固定化手続き（生成・検証・統合）の対象として扱う。破壊的変更は、差分検査で検出された時点で通常の実装変更とは別扱いになり、統合するには移行の定義を必須とする。外形では検出できない互換性（解釈・分類・運用前提）に関わる変更は、OpenAPI差分だけでは判定できないため、境界の振る舞いを固定するテスト（契約テスト、または境界レベルの性質テスト）を併置し、それが落ちる変更は統合されない、という形で固定化条件に組み込む。

ここで言う移行は、「破壊的変更を許す代わりに、利用側が追従できる時間と手順を用意する」ことである。移行の形は段階移行かバージョニングか同時リリースのいずれかに整理できるが、重要なのは方式名ではなく、破壊が固定化される前に「追従の道筋が定義されている」ことである。段階移行なら、旧仕様が残る期間と廃止条件が定義され、旧仕様が残っていること自体が固定化条件になる。バージョニングなら、v1とv2が並行稼働できる形が存在し、切替期限と終了条件が定義されることが固定化条件になる。同時リリースなら、利用側の変更が同一の統合単位に含まれていることが固定化条件になる。いずれにせよ、「破壊的変更がある」という事実が差分で観測された瞬間に、その変更は移行定義の有無へ従属するべきであり、移行定義が存在しない破壊は固定化されない。

この方針を“運用の気合い”ではなく“検証手続き”に落とすには、破壊的変更を検出したときにCIが何を要求するかを決める必要がある。たとえば、OpenAPI差分検査が破壊的変更を検出した場合、そのPRが「段階移行」「バージョニング」「同時リリース」のいずれで処理されるのかが、リポジトリ上の成果物として明示されていなければならない。ここで成果物とは、単なる説明文ではなく、機械的に存在を確認でき、差分として追える形であることが望ましい。これにより、破壊的変更の固定化可否は「移行が定義されているか」という一点に従属し、レビューの場で移行の有無が曖昧なまま統合される余地が減る。

### 7.6 ドメイン不変条件をどの粒度で外部化するか

次に、ドメインの不変条件をどの粒度で外部化するか、という論点に移る。ここで外部化とは「ドメインの性質をテストとして表現し、固定化の条件としてCIに載せる」ことだった。不変条件を外部化する粒度は、単にテストを細かくする／統合テストを増やす、といった話ではなく、「どの性質を固定化条件として宣言し、どの性質は探索に委ねるか」という線引きである。この線引きが曖昧だと、固定化条件が増えず枝を切れないか、逆に無秩序に増えて探索可能性を過剰に潰すか、どちらかに寄りやすい。

粒度を決めるためには、不変条件を“性質の種類”で整理するのがよい。たとえば、権限違反や越権操作のように一度でも起きればシステムの性質が崩れるもの、整合性違反（参照整合、重複、二重適用、取り消し不能な状態の破壊）のようにデータを汚染するもの、そして境界越しに観測される意味の一貫性（同じ入力に対して許される結果の範囲がある、など）のように利用側の前提になるものは、固定化条件として優先度が高い。逆に、実装効率や内部構造の好み、リファクタのスタイルのようなものは固定化条件として持ち込むと、探索を不必要に拘束しやすい。ここで固定したいのは「こう書け」ではなく「こうなってはいけない／こうでなければならない」という性質だからである。

したがって本設計では、ドメインの不変条件を次のように外部化していく方針を採る。まず、破られると修復コストが高い性質を固定化条件として優先的にテスト化する。次に、境界で観測される意味の一貫性のうち、OpenAPI差分では捉えられないものを、境界レベルのテストとして追加する。最後に、探索の過程で実際に踏まれた誤り（不適切な枝）があった場合、その誤りを二度固定化しないための反例としてテストを追加し、固定化条件を増やす。この増やし方は、テストを増やすこと自体が目的なのではなく、「固定化の条件が実装に従属しない」関係を維持するための手続きである。

ここまでをまとめると、次に具体化すべきものは、境界については「契約更新の分類」と「破壊的変更時の移行定義を、どの成果物としてリポジトリに置き、CIがどう要求するか」であり、ドメインについては「不変条件をどの種類からテストとして外部化し、どの範囲を固定化条件に含めるか」である。以降では、この二点を、実際のファイル配置とCIの検証順序に結びつけ、固定化の条件が手続きとして閉じる形まで落としていく。

## 8. ファイル配置とCIの検証順序

### 8.1 ここで結ぶべきもの

以降では、この二点を、実際のファイル配置とCIの検証順序に結びつけ、固定化の条件が手続きとして閉じる形まで落としていく。

まず、リポジトリに置くべき成果物は、「探索結果（実装）」そのものではなく、探索結果を落とすための一次情報と固定化条件である、という整理を先に置く。探索主体が生成するのは主に実装だが、固定化可否を決める側（レール）は、差分として追え、機械的に参照でき、かつ変更手続きが定義されている必要がある。したがって、境界の外形はOpenAPIとして、破壊的変更の追従手順は移行定義として、外形では検出できない互換性は境界テストとして、そして構造制約は静的検査設定として、それぞれ「変更されうるが、変更の仕方が規律化された成果物」としてリポジトリに常置されるべきである。

### 8.2 境界：OpenAPI差分検査を最初の関所にする

境界については、OpenAPIを単一参照点として固定する以上、契約は「人間が読む説明」ではなく「差分で観測できる一次情報」でなければならない。したがって、OpenAPIファイルは生成物ではなく手書き（または最終的に人間がレビューし差分を引き受ける対象）として管理し、型やクライアントはそこから生成される側に置く、という依存関係を崩さないことが重要になる。ここで固定したい関係は、実装が契約を事後的に説明するのではなく、契約差分が固定化可否を支配する、という従属関係である。

この従属関係をCIの手続きに落とすと、OpenAPI差分検査は最初の関所になる。PRに含まれるOpenAPI差分を解析し、後方互換な変更であれば通し、破壊的変更であれば「移行定義の存在」を要求する。ここで「存在」とは、説明文が書かれていることではなく、機械的に存在確認でき、差分として追える成果物が追加・更新されていることを指す。たとえば、破壊的変更を検出した場合に、リポジトリ上に移行定義ファイル（形式はYAMLでもJSONでもよいが、必須項目がスキーマで検証できる形）が同一PRに含まれていることを要求する、という形になる。移行定義に含めるべきなのは、方式名そのものよりも、追従の道筋が具体化されていることだ。すなわち、段階移行なら「旧仕様を残す範囲」と「廃止条件（期限や削除条件）」、バージョニングなら「並行稼働の成立条件」と「切替期限と終了条件」、同時リリースなら「利用側変更が同一統合単位に含まれること」が、機械的に確認できる形で表現されている必要がある。CIは、破壊的変更という事実が観測された瞬間に、そのPRを移行定義の有無へ従属させ、移行定義が欠ける破壊は固定化されない、という手続きを実行する。

### 8.3 外形では検出できない互換性：境界テストを併置する

一方で、外形では検出できない互換性（解釈・分類・運用前提）については、差分検査だけでは判定できない以上、固定化条件は境界テストとして外部化される必要がある。ここで言う境界テストは、単にレスポンスの型が合うことを確認するものではなく、利用側の前提を壊さないことを観測可能な形にしたものになる。たとえば「POST /orders が accepted を返すときは直後に確定状態が観測できる」「未登録emailは404である」「権限不足は403である」「返ってよい通貨コード集合が制約される」「同一idempotency-keyで副作用が重複しない」といった性質は、OpenAPIの外形からは直接には落ちないが、境界を跨いだ観測としてはテストに落とせる。この種のテストをリポジトリに常置し、契約更新と同様に差分として追える固定化条件として扱うことで、「外形は同じだが前提が壊れる」変更が統合される確率を下げる。

このとき重要なのは、境界テストの位置づけが「実装の正しさを証明する」ではなく、「固定化してはいけない枝を落とす」ことにある点である。境界テストは、実装詳細に寄せるほど探索を拘束するが、前提を表現しないほど枝を切れない。したがって、境界テストが固定すべき対象は“やり方”ではなく“前提として残ってほしい性質”であり、上の(1)〜(5)のような、利用側の分岐や運用の安全性に直結するものから優先して外部化していく、という方針が自然に導かれる。

### 8.4 アーキテクチャ：構造制約を静的検査に落とす

アーキテクチャの構造制約については、固定化の条件を静的検査として表現するのが分かりやすい。ここで固定したいのは、依存方向や越境の禁止が、人間のレビュー注意力に回収されないことだ。したがって、構造制約は「コード上の規約」ではなく「検査対象としての規則」として、設定ファイルやルール定義としてリポジトリに置かれる。Goであればパッケージ境界とimport制約、TypeScriptであればモジュール境界とimport規則がこの役割を担える。こうした規則は、探索主体が局所的に“便利だから”と破りやすい箇所を、機械的に落とすための固定化条件として位置づけられる。

### 8.5 CIの検証順序と依存関係

以上を踏まえると、CIは「自動テストを回す場」ではなく、固定化の関所として構成される。検証順序は任意ではなく、依存関係に従って決まる。契約差分検査が先に走るのは、契約が一次情報であり、破壊的変更の有無が以降の手続き（移行定義の要求）を支配するからである。構造検査が早い段階に置かれるのは、構造違反は実行以前に落とせ、かつ探索空間の制約を破る変更を早期に遮断できるからである。境界テストとドメインテストは、外形・構造を通過した後に、前提と性質を固定化条件として評価する。ここでの要点は、固定化可否が「差分（契約）」「構造（越境）」「性質（前提・不変条件）」という異なる種類の判定へ従属していることが、手続きとして明示される点にある。

### 8.6 失敗時の振る舞いも設計に含める

最後に、失敗時の振る舞いも設計に含める必要がある。固定化の関所としてのCIが落ちるということは、探索結果が不適切であることを意味するが、それは探索が無意味だったことを意味しない。落ちた理由は、次の探索で枝を切るための一次情報として扱われるべきである。具体的には、契約差分で落ちたなら契約更新の意図と移行定義の不足が問題であり、境界テストで落ちたなら利用側前提を壊していることが問題であり、構造検査で落ちたなら探索空間の制約を破っていることが問題である。このように「どの関所で落ちたか」がそのまま修正方針に接続されるよう、関所の設計は、落とす種類が混線しない形で組み立てられる必要がある。

### 8.7 次の焦点：移行定義と境界テストの成果物化

ここまで落とすと、次に具体化すべき焦点はさらに絞られる。ひとつは、破壊的変更を検出したときにCIが要求する「移行定義」を、どの形式・どの必須項目でリポジトリに置くかである。もうひとつは、外形では検出できない互換性（解釈・分類・運用前提）を固定する境界テストを、どの範囲から追加し、どの粒度で「前提」として扱うかである。以降では、この二点を、具体的な成果物の形（ファイルとしての置き方と検証方法）に落としていく。

## 9. 移行定義と境界テストを成果物として閉じる

### 9.1 破壊的変更を許すときの固定化条件

以降では、破壊的変更を検出したときに要求する「移行定義」と、外形では検出できない互換性を固定する「境界テスト」を、どちらもリポジトリ上の成果物として閉じる形に落とす。ここで重要なのは、どちらも「説明文」ではなく「差分として追えて、機械的に参照できる」ことだ。説明文は補助にはなるが、固定化可否を支配する一次情報にはなりにくい。一次情報になれるのは、形式があり、存在が確認でき、欠落や不整合を機械的に検出できる成果物だけである。

まず移行定義を考える。破壊的変更が観測された瞬間に、その変更を「移行定義の有無」へ従属させる、という方針を実際の手続きにするには、少なくとも次の二点が必要になる。ひとつは、破壊的変更を検出したときに「どの移行定義ファイルを見ればよいか」をCIが特定できること。もうひとつは、その移行定義ファイルが「追従の道筋」を最低限の粒度で表現しており、しかもその形式が検証できることだ。

### 9.2 移行定義の置き場を固定する

この二点を満たすために、リポジトリの中に移行定義の置き場を固定する。たとえば `contracts/migrations/` のようなディレクトリを単一の置き場として決め、破壊的変更を含むPRでは必ずここに移行定義ファイルが追加される、という規則にする。CIは、OpenAPI差分検査で破壊的変更を検出した場合、同一PR内に `contracts/migrations/` 配下の新規ファイルが存在することを要求し、存在しなければ落とす。これで「移行定義があるかどうか」は、説明文ではなくファイルの有無として機械的に確定する。

### 9.3 移行定義ファイルを形式化する

次に、その移行定義ファイルの中身を形式化する。ここで形式化の目的は、完璧な自動化ではない。人間の設計判断が必要な部分を残したままでも、少なくとも「追従の道筋が定義されている」ことが曖昧にならないようにすることだ。したがって、移行定義ファイルは、方式名を列挙するだけでは足りない。段階移行・バージョニング・同時リリースのいずれを採用しても、共通して必要になる要素がある。すなわち、(a) 何が破壊なのか、(b) 追従のために何を残し、いつまで残すのか、(c) いつ何をもって移行完了とみなすのか、である。

たとえばYAMLで置くなら、最低限として次のような形に落とせる。ここでは「これが唯一の正解」とは言わないが、CIが検証できる粒度まで下ろす、という目的には沿う。

```yaml
id: "2026-02-03-drop-field-x"
api:
  from: "v1"
  to: "v1"        # 段階移行の場合は同一のままでもよい
breaking:
  - kind: "remove_field"
    location: "GET /users 200"
    field: "nickname"
strategy: "staged"  # staged | versioned | atomic
plan:
  staged:
    deprecate_at: "2026-03-01"
    remove_at: "2026-06-01"
    compatibility_window: ">=90d"
    requirements:
      - "旧フィールドはremove_atまで返し続ける"
      - "新フィールドはdeprecate_atから提供する"
  # versioned / atomic の場合も同様に必須項目を定める
validation:
  required_artifacts:
    - "openapi change includes deprecated marker"
    - "consumer update included (if atomic)"
```

この例で肝心なのは、細部ではなく構造だ。CIが見たいのは「方式名」ではなく、追従の道筋が最低限の項目として存在すること、そしてその日付や条件が欠けていないことだ。したがってCIは、`contracts/migrations/` 配下のYAMLが所定のスキーマに合致すること（必須キーの存在、日付形式、strategyの列挙値など）を検証できるようにしておく。これにより、破壊的変更が観測されたにもかかわらず「移行？まあそのうち」みたいな状態で統合される余地が減る。人間は「この移行計画で妥当か」をレビューするが、少なくとも「移行計画が存在しない」という状態は機械的に排除される。

### 9.4 CIが検証する観点

ここまでで、破壊的変更に関しては「差分検知 → 移行定義要求 → 形式検証」という手続きが成立する。しかし、もう一方の問題である「外形では検出できない互換性（解釈・分類・運用前提）」は、同じ形では落ちない。差分検査は外形の変化を検知するが、解釈や運用前提の変化は、外形が同一でも起こりうるからだ。したがって、この種の変更を落とすには、外形ではなく「境界を跨いだ観測」を固定化条件として外部化するしかない。これが境界テストの位置づけになる。

境界テストを成果物に落とすときに、まず固定すべきなのは「何を境界テストと呼ぶか」ではなく、「境界テストが参照する一次情報は何か」だ。本設計では、契約の一次情報はOpenAPIであり、外形では検出できない互換性はテストで固定する。ここでの依存関係を崩さないために、境界テストは少なくとも二種類に分けて考える必要がある。ひとつは、OpenAPIが表現している外形が守られていることを確認するテスト（型・必須性・ステータスコードの最低限の整合）。もうひとつは、OpenAPIの外側にある前提（解釈・分類・運用前提）が守られていることを確認するテストだ。後者が今回の論点であり、これがないと「外形は同じだが前提が壊れる」変更を落とせない。

### 9.5 外形では検出できない互換性と境界テスト

この後者を具体的な成果物として置くなら、テストは「代表シナリオ」として書かれる必要がある。代表シナリオとは、実装の詳細ではなく、境界越しに観測される事後条件を固定するものだ。すでに挙げた(1)〜(5)は、そのまま代表シナリオへ落とせる。`POST /orders` の返り値が `accepted` であるだけではなく、その直後に確定状態が観測できることを固定する、未登録emailが404であることを固定する、権限不足が403であることを固定する、返ってよい値集合を固定する、同一キー再送で副作用が重複しないことを固定する。これらは、実装内部がどう書かれていても、利用側の前提として変わってほしくない性質であり、だからこそ固定化条件として外部化する意味がある。

重要なのは、これらのテストが「契約更新の分類」と同じ位置に置かれることだ。つまり、外形を変えない変更であっても、境界テストが落ちるなら統合されない。逆に、境界テストを更新するなら、それは「前提を変える」という設計判断であり、通常の実装変更とは別のレビュー軸になる。この関係を成立させるためには、境界テストが散発的に増えるのではなく、「前提として固定するものの置き場」としてまとまって存在している必要がある。たとえば `contracts/tests/` のようなディレクトリを設け、そこに「外形外の前提を固定するテスト」を集約する。これにより、前提の変更は「テストの差分」として明確に観測されるようになる。

### 9.6 境界テストの置き場と実行形態

ここまでをリポジトリ構造としてまとめると、少なくとも次のような関係が固定されることになる。OpenAPIは境界外形の一次情報であり、差分検査の入力である。移行定義は破壊的変更の追従手続きを表現する成果物であり、差分検査の結果に従属して要求される。境界テストは外形では検出できない前提を固定する成果物であり、OpenAPI差分とは独立に落ちる。いずれも、探索主体が生成してよい対象ではあるが、統合の可否を支配する一次情報として扱う以上、最終的には人間が差分を引き受け、更新の意味をレビューする対象になる。

### 9.7 次にやること

次に詰めるべき具体点は、この「置き場の固定」をさらに一段下ろすことである。すなわち、OpenAPIをどこに置き、生成物（型・クライアント）をどこに吐き、移行定義をどのスキーマで検証し、境界テストをどの実行環境で走らせるか、である。ここまで落とすと、CIの各関所が参照するファイルと実行単位が明確になり、固定化可否が「運用の気合い」ではなく「手続き」へ寄る。以降では、想定するGoバックエンド／TSフロントエンドの構成を前提に、これらの置き方と検証順序を具体化していく。

## 10. Goバックエンド／TSフロントエンドでの具体化例

### 10.1 前提とする構成

以降では、想定するGoバックエンド／TSフロントエンドの構成を前提に、これらの置き方と検証順序を具体化していく。

### 10.2 一次情報の置き場を固定する

まず、リポジトリの中で「一次情報」として扱う成果物の置き場を固定する。ここで固定したいのは、どのファイルを見れば契約が分かるのか、どのファイルを見れば破壊的変更の追従が分かるのか、どのファイルを見れば外形では検出できない互換性（解釈・分類・運用前提）が分かるのか、という参照点である。参照点が揺れると、差分が追えず、固定化可否が再び説明文やレビューの注意力に戻ってしまう。

したがって、境界まわりの成果物は `contracts/` に集約し、ここが固定化手続きの起点になるように置く。OpenAPI、移行定義、境界テスト（外形では検出できない前提を固定するテスト）は、同じ階層に並ぶべきで、いずれも「変更されうるが、変更の仕方が規律化されたもの」として扱う。具体的な配置は一例として次のようになる。

### 10.3 `/contracts/` 配置例

```text
/contracts
  /openapi
    api.yaml                 # 単一参照点（一次情報）
  /migrations
    *.yaml                   # 破壊的変更の追従を表現する成果物
  /boundary
    conformance.test.go      # OpenAPIで固定した外形への準拠（外形に沿った振る舞い）
    assumptions.test.go      # 外形では検出できない前提を固定する境界テスト（解釈・分類・運用前提）
    fixtures/                # テストで使う入力・期待値（必要なら）
/backend
  /cmd/api                   # HTTPサーバ
  /internal                  # アプリケーション本体
  /gen                       # OpenAPIから生成される型・クライアント（生成物）
/frontend
  /src
    /gen                     # OpenAPIから生成される型・クライアント（生成物）
```

ここで重要なのは、`/contracts/openapi/api.yaml` が一次情報であり、`/backend/gen` や `/frontend/src/gen` はそれに従属する生成物だという関係が崩れないことだ。生成物をコミットするかどうかは流儀が分かれるが、本設計の文脈では「差分として観測できること」を重く見ているため、生成物をコミットし、CIで再生成して差分が出たら落とす、という形が分かりやすい。こうしておくと、OpenAPIの差分が生成物の差分へ必ず伝播し、契約変更が“見える形”で固定化手続きに入る。

### 10.4 一次情報と生成物の従属関係

次に、CIを関所として組み立てる。CIの役割は「全部の自動テストを回す」ことではなく、固定化可否を決める判定を、種類ごとに分離して実行することだ。ここでの種類とは、すでに置いた三つの違反（契約、性質、構造）である。これらを混ぜると、落ちたときに何を直すべきかが曖昧になり、失敗が一次情報にならない。

### 10.5 CIを関所として組み立てる

CIの流れは、依存関係に沿って次の順序で組むのが自然になる。まずOpenAPIの妥当性検証を行い、次にOpenAPI差分検査を行い、破壊的変更がある場合は移行定義の存在と形式を要求する。その後に生成を行い、構造検査を行い、最後にテストを走らせる。順序の意図は、破壊的変更の有無という事実が、以降の要求（移行定義の必須化）を支配すること、構造違反は実行以前に落とせること、境界テストとドメインテストは外形と構造が通った後に“前提と性質”を評価することにある。

この手続きをもう少し具体にすると、たとえば次のような関所になる。

### 10.6 CIの検証順序

OpenAPIの関所では、(a) OpenAPIが仕様として正しいこと（構文・参照・型の整合）、(b) 既存との差分がどの種類か（後方互換・破壊的・判定不能領域）、を機械的に確定する。差分検査は、単に“差分がある”ではなく“破壊的差分がある”を検出できなければ意味がない。破壊的差分が検出された場合、そのPRは自動的に「移行定義の存在」へ従属する。つまり、移行定義ファイルがない限り、その変更は固定化されない。

移行定義の関所では、(a) 置き場（`contracts/migrations/`）にファイルが存在すること、(b) ファイルがスキーマに合致していること（JSON SchemaやCUE等で検証する）、を機械的に確定する。ここでスキーマに含めるべきものは、方式名よりも追従の道筋が定義されていること、すなわち「何が破壊なのか」「何をいつまで残すのか」「何をもって移行完了とするのか」が欠けていないことだ。CIはこの欠落を落とす。妥当性（本当にその日付でよいか等）は人間がレビューするが、「そもそも追従が定義されていない破壊」は機械的に排除される。

生成の関所では、OpenAPIからバックエンド・フロントエンド双方の生成物を生成し、リポジトリにコミットされている生成物と一致することを要求する。ここが落ちた場合は「一次情報（OpenAPI）と生成物がズレている」か「生成手続きが変わった」のどちらかであり、原因が明確になる。探索主体が実装を生成するときに、生成物を勝手に編集する方向へ逸脱しても、この関所で落ちる。

構造の関所では、依存方向・越境を落とす。Goであれば `internal` の境界やパッケージ分割に加えて、禁止importの検査（`depguard` 等）を使って「境界を跨いで依存してはいけない」を機械化できる。フロントエンド側も、モジュール境界をeslintのルール等で検査対象に落とせる。ここで固定したいのは“美しい構造”ではなく、“越境してはいけない”という探索空間の制約である。

### 10.7 各関所が落とすべきもの

テストの関所では、境界テストとドメインテストを分けて走らせる。境界テストは `contracts/boundary/` に置かれ、外形では検出できない互換性（解釈・分類・運用前提）を、境界越しの観測として固定する。ここが落ちたなら、実装が前提を壊したか、前提（テスト）を更新すべき変更を行っているかのどちらかであり、いずれにせよ「前提をどう扱うか」という設計判断に戻れる。一方でドメインテストはバックエンド内部に置かれ、不変条件（権限、整合、二重適用、取り消し不能な状態の破壊など）を固定する。ここが落ちたなら、探索結果が不変条件を破っているので、固定化されない。

ここまでがCIの骨格であり、これを日々の作業手続きに落とすと、変更の種類ごとに手順が決まる。ここで「変更の種類」とは、実装変更、契約更新、破壊的変更、外形では検出できない前提の変更の四つが中心になる。重要なのは、契約更新や前提の変更が“実装のついで”にならず、差分として観測され、レビュー対象として独立することだ。

加えて、探索主体に実装とテストを同時に生成させる運用では、
実装の誤りに合わせてテストが更新される（固定化の条件が探索結果に従属する）リスクがある。
したがって、OpenAPI・移行定義・境界テスト・ドメインテスト・構造ルールといった固定化条件の変更は、
実装変更とはレビュー軸を分け、少なくとも差分を先に読む（可能ならPRを分ける）などの扱いで、
「固定化条件が一次情報である」関係を保つ。

通常の実装変更では、OpenAPIは変えない。探索主体（AI）が実装を生成してもよいが、CIの関所（構造、テスト）を通るかどうかだけが固定化可否を決める。ここで人間がすべきことは、探索主体に「どの前提に従うべきか」を明示し、越境や前提破りが起きたら、その原因がどの関所で落ちたかに沿って修正することだ。

契約更新を含む変更では、OpenAPIの差分が一次情報になる。実装より先にOpenAPIを更新し、その差分が何に当たるか（後方互換か、破壊的か、あるいは外形では検出できない前提に波及しうるか）を、差分検査と人間の判断の両方で確定させる。そのうえで生成物を更新し、実装を追従させる。ここでのポイントは「実装が先に進み、後からOpenAPIが追記される」順序を避けることだ。順序が逆転すると、契約が探索結果に従属し、固定化可否が曖昧になる。

破壊的変更を含む契約更新では、OpenAPI差分検査が破壊的変更を検出した瞬間に、移行定義が必須になる。移行定義がない破壊は固定化されない。ここで移行定義に書くべきことは、方式名ではなく追従の道筋であり、段階移行なら旧仕様を残す期間と廃止条件、バージョニングなら並行稼働と切替条件、同時リリースなら利用側の変更が同一統合単位に含まれること、といった「追従が成立する条件」を明示する。CIはこの存在と形式を検証する。人間のレビューは、この追従が現実に成立するか（期限、影響範囲、利用側の準備）を判断するが、少なくとも「追従の道筋がない破壊」が通過することはなくなる。

外形では検出できない前提に関わる変更では、境界テストが一次情報になる。これは、OpenAPI差分だけでは“前提の破れ”を機械判定できないからである。したがって、前提を変えるなら境界テストが変わる。その差分が「前提を変えた」という事実の観測になる。ここで扱うべきなのは、前提変更がよいか悪いかではなく、前提変更が“設計判断として分離されているか”である。実装の変更に紛れて前提が変わると、前提が汚染され、以降の探索の入力が変質する。境界テストの差分を必ず伴うようにすると、前提変更は常に“見える差分”として固定化手続きに入る。

### 10.8 失敗時の扱い

関所が落ちたとき、次に何を直すべきかは「どの種類の違反で落ちたか」に従属させる。つまり、失敗はそのまま修正方針の一次情報になる。

| 落ちた関所 | 何が起きているか | 次に探索主体へ返す指示の型 |
| --- | --- | --- |
| OpenAPI差分/互換性 | 契約を破っている、または破壊を含む | 契約を戻すか、移行定義を追加する |
| 構造検査 | 依存方向・越境のルール違反 | 依存を正方向へ戻し、越境を解消する |
| 境界/ドメインテスト | 前提や不変条件（性質）を破っている | 該当する性質が満たされるよう実装を修正する（必要なら固定化条件側を更新する） |

この仕組みを、AIとの協業手順として言い換えるなら、探索主体に触らせてよい領域と、触らせるとしても人間が差分を引き受ける領域が分かれる。実装は探索主体が生成してよいが、OpenAPI、移行定義、境界テスト、構造制約は、統合の可否を支配する一次情報なので、最終的に人間が差分の意味をレビューし、必要なら修正する対象になる。探索主体がOpenAPIを書き換えること自体は可能だが、それは「仕様を変える」という設計判断を含むため、通常の実装生成と同列には置けない。ここでの区別は、能力の問題ではなく、固定化手続きの役割分担の問題である。

さらに、この設計を規模拡大に耐える形にするには、契約と前提の置き場が増えても参照点が崩れないようにする必要がある。単一のOpenAPIに収め続けることもできるが、境界が増え、領域が分かれてくると、契約の単位を分割して「どの契約がどの境界を支配するか」を明示したくなる。ここでの分割は、マイクロサービス化を意味しない。単一リポジトリのままでも、契約の単位（bounded context的な単位）を `contracts/openapi/{context}.yaml` のように分け、対応する移行定義や境界テストも同じ単位で束ねられる。CIも、変更された契約単位に応じて差分検査・移行定義要求・境界テストを走らせる対象を絞れる。これにより、規模が増えても「何を見ればよいか」が崩れにくい。

最後に、この設計が扱っている失敗モードに戻る。問題は探索が分岐すること自体ではなく、不適切な枝が固定化され、以降の前提が汚染されることだった。ここまでで構成したのは、汚染が起きる地点を、契約（OpenAPI）、追従（移行定義）、前提（境界テスト）、構造（静的検査）、性質（ドメインテスト）という成果物と関所に分解し、それぞれを差分として観測できる形に置いたうえで、固定化可否を関所の判定へ従属させる手続きである。

### 10.9 まとめ

この手続きが成立していれば、探索主体の出力がもっともらしいかどうか、という評価は固定化可否の中心から外れる。もっともらしく見える出力でも関所で落ちる。逆に、実装の細部がどうであれ、前提と性質が守られていれば固定化されうる。したがって以降の実装作業は、探索主体に任せる／任せないの議論ではなく、一次情報と固定化条件をどこまで明確に置けているか、そして関所がどの種類の違反を落とすのかが混線していないか、という検査へ寄る。

以上で、この設計が「レール」を具体の成果物と検証手続きに落とすところまでを一通り閉じた。残る作業は、実際に採用する生成器・差分検査ツール・静的検査ルール・テスト実行環境を決め、上の置き場と関所に接続することである。ただしそれは個別技術の選定であり、ここまでで定義したのは「なぜそれらが必要になるか」「どこに接続されるべきか」という型である。技術は差し替え可能だが、一次情報の位置と固定化可否の従属関係が崩れると、この設計は成立しない。ここを崩さない範囲で、具体技術を選び、運用に落としていく。

## 付録：後回し

- 境界テストの分類（外形への準拠 / 外形では検出できない前提）を、ファイル/命名/タグとしてどこまで明示するか。
- 移行定義（`contracts/migrations/*.yaml`）のスキーマをどこまで固定し、CIでどこまで機械検証するか。
- 固定化条件（OpenAPI/テスト/ルール）の更新を、実装変更とどう分離してレビューするか（PR分割・ラベル・チェックリスト等）。
- CI失敗時のフィードバック文（探索主体への指示テンプレート）をどこまで標準化するか。
