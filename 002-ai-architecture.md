# TL;DR
なにか

# 1

設計方針：確率的な生成過程を開発系に入れたときの安定化条件

本設計では、AIを「知識を保持し一貫した判断を行う主体」としてではなく、
読み込んだ文脈に条件づけられて、確率的に次の一手を生成する生成過程として扱う。

ここで言う「探索」とは、AIが目的を持って探索するという意味ではない。
出力が多分岐になりうる生成過程を、開発プロセス上は探索として取り扱う、という意味である。

曖昧さを含む文脈を入力とする限り、AIの出力は本質的に多分岐になる。
それぞれの出力は局所的にはもっともらしく見えるが、そのすべてがシステム全体にとって適切であるとは限らない。

したがって、AIを開発に導入することは
「実装を自動化する」ことではなく、
実装の探索が高速かつ多分岐になる状況を受け入れることを意味する。

問題は、探索によって不適切な枝が生成されること自体ではない。
問題になるのは、不適切な枝がそのまま統合され、
以降の開発における前提として固定化されてしまうことである。

この観点から見ると、本設計が扱う課題は
「確率的な探索主体を開発系に入れたときの安定化条件」になる。

ここで言う安定化とは、
探索（生成）が継続しても、システムが持つべき性質が崩れないことを指す。
言い換えれば、

探索（生成）と固定（統合）が分離され、
固定されるのは検証を通過したものだけ、
という構造を作ること
である。

この構造を成立させるためには、二つの仕組みが必要になる。

一つは、探索の範囲をあらかじめ制限することだ。
アーキテクチャ、境界、責務分離、依存方向といった設計要素は、
AIに正解を教えるためのものではなく、
探索が向かってよい方向と、向かってはいけない方向を定めるためのものとして機能する。

もう一つは、探索の結果を選別することだ。
生成された実装や変更のうち、
設計として許容できないものが統合されるのを防ぐ必要がある。
そのために、契約、不変条件、互換性といった性質を事前に定義し、
それらを満たさない変更を機械的に遮断する。

本ドキュメントで言う「レール」とは、
この固定化の条件をシステムの外側から定義する装置を指す。

レールは、良い出力を信頼するためのものではない。
悪い枝が固定化されないことを保証するための構造である。

# 2

ここで扱っている二つの仕組み、すなわち
「探索の範囲を制限すること」と「探索の結果を選別すること」は、
役割が異なるため、本ドキュメントでは意識的に区別して扱う。

探索の範囲を制限する設計要素は、探索が行われる前に存在する。
それらは、探索主体がどの方向に枝を伸ばせるかをあらかじめ規定し、
到達してほしくない領域を探索空間から除外する役割を担う。

一方で、探索の結果を選別する設計要素は、探索が行われた後に作用する。
探索によって生成された枝のうち、
固定化してよいものと、固定化してはいけないものを分ける役割を担う。

この二つは同一のものではないため、
本ドキュメントではレールを次の二つの要素に分けて扱う。

第一に、探索空間の制約である。
これは、実装が生成される前提として、
どの方向に探索が進んでよいかを定める。

第二に、固定化の条件である。
これは、生成された実装や変更が、
統合されてよいかどうかを判断する基準である。

以降では、この二つの観点をもとに、
探索空間の制約として何を先に決めておくべきか、
固定化の条件として何を検証可能な形で定義すべきか、
そしてそれらをどこで検証するかを整理していく。

このドキュメントの次の仕事は、以上の抽象をさらに一段だけ具体化して、「境界」「ドメイン」「アーキテクチャ」それぞれについて、探索空間の制約として何を外部化するか、固定化の条件として何を定義するか、検証地点として何を置くか、を列挙できる形にすることである。

ここで言う「列挙」とは、たとえば次のように、同じ対象を三つの観点に割り当てて書くことを指す。

例として、API のエラー表現を考える。
エラー表現は境界に現れるため、「境界（契約）」として固定されるべき対象になる。したがって、

探索空間の制約：エラーのレスポンス形式（フィールド構造）を固定する

固定化の条件：実装がその形式を破っていないこと（互換性違反がないこと）

検証地点：CI で契約検証（スキーマ検証や互換性チェック）を行う

同じように、ドメインの不変条件を考える。
たとえば「ある状態ではこの操作を許さない」という条件は、実装手順ではなく性質として固定化されるべき対象になる。したがって、

探索空間の制約：状態遷移や権限判定がドメイン（またはドメインに近い層）に集約されるように構造を決める

固定化の条件：禁止された操作が成功しないこと（不変条件が破れないこと）

検証地点：テストでその禁止条件を検証する

このように、対象を「探索の前提」「固定化の条件」「検証地点」に割り当てることで、レールが「何となく気をつけること」ではなく、実装と検証に落ちた具体的な形として記述できる。

# 3

次に行うのは、対象を三つの観点――探索空間の制約／固定化の条件／検証地点――へ割り当てる作業である。ここでは、どのアプリでも必ず現れる対象から始める。題材固有の仕様は後で足せるが、ここで作る骨格は題材が変わっても残る。

まず境界（HTTP API）について考える。境界は外部に露出するため、探索の結果がそのまま外部契約の差分になる領域である。したがって境界では、探索空間の制約は「外形を固定する」という形を取り、固定化の条件は「外形を破っていないこと」という形を取り、検証地点は「統合前に機械的に判定できること」という形を取る。

例として、APIのエラー表現を考える。エラー表現は外形であり、実装詳細ではない。したがって、探索空間の制約としては、エラーレスポンスの形式（フィールド構造と最低限の分類）を固定する。固定化の条件としては、実装がその形式を破らないこと、そして既存の意味を変えないこと（互換性の維持）を置く。検証地点としては、CIにおいてスキーマ検証や互換性チェックを行い、違反した変更が統合されないようにする。

同様に、成功時のレスポンス構造も境界の外形である。探索空間の制約としては、レスポンスのスキーマを固定する。固定化の条件としては、既存クライアントが期待しているフィールドの削除や型変更を行っていないことを置く。検証地点としては、契約検証と回帰テストによって、統合前に差分を検出する。

ここまでで境界の論理は一段落する。境界は「外形が固定される」領域であり、探索は内側で許容される。この区切りが曖昧だと、探索結果が外部契約の差分として固定化されてしまう。したがって、境界に関しては「契約として固定し、契約として検証する」という形でレールを敷くことになる。

次にドメインについて考える。ドメインは外形ではなく意味の領域であり、探索の結果が「ビジネス上許されない状態」を作る枝を生みうる。ここで固定されるべきなのは処理手順ではなく、到達してよい状態と到達してはいけない状態の区別である。したがってドメインでは、探索空間の制約は「意味が集約される場所を決める」という形を取り、固定化の条件は「禁止された結果に到達しないこと」という形を取り、検証地点は「禁止条件を落とすテスト」という形を取る。

例として、状態が存在する対象を考える。たとえば、何らかの“申請”“投稿”“注文”“タスク”のように、作成され、更新され、ある時点で確定する対象である。ここで一般に問題になるのは、「確定後に変更してよいのか」「ある状態で実行してよい操作は何か」といった条件である。これらは実装手順ではなく性質であり、探索がどれだけ多分岐しても維持されるべき対象になる。したがって、探索空間の制約としては、状態遷移や権限判定がドメイン（またはドメインに近い層）に集約されるように構造を決める。固定化の条件としては、禁止された操作が成功しないこと、禁止された遷移が起きないことを置く。検証地点としては、その禁止条件をテストで表現し、統合前に落とす。

ドメインではもう一つ、整合性の条件が現れる。たとえば「同じキーは重複できない」「関連する値が揃っていなければならない」といった条件である。これも性質であり、探索の結果として破られてはならない。探索空間の制約としては、整合性に関わる判断が散らばらず、一箇所で行われるように設計する。固定化の条件としては、整合性が破れる入力や状態の組が成功しないことを置く。検証地点としては、テストと、必要ならDB制約のような二重化された検証を置く。

最後にアーキテクチャについて考える。アーキテクチャは、境界やドメインで定義した制約・条件が実装として維持されるように、探索空間の地形を作る領域である。ここでの探索空間の制約は、関心事が混線しないように構造を決めることになる。固定化の条件は、その構造が破られていないことになる。検証地点は、構造違反を統合前に検出できる場所になる。

例として、依存方向を考える。ドメインが外部I/Oに直接触れ始めると、ドメインの性質は実装都合に侵食されやすくなる。これは「良い／悪い」ではなく、ここまで述べたレール（契約・不変条件）を維持するための都合である。したがって探索空間の制約としては、外部I/Oは境界とインフラ層に閉じ、ドメインはそれに依存しない、という依存方向を置く。固定化の条件としては、その依存方向が破られていないことを置く。検証地点としては、静的解析やimportルール、パッケージ構造の検査をCIに組み込み、違反が統合されないようにする。

ここまでで、境界・ドメイン・アーキテクチャの三観点について、対象を「探索空間の制約／固定化の条件／検証地点」に割り当てるという操作が可能になった。次の段階では、この割り当てを、実際に採用する技術要素――たとえばOpenAPI、型、テスト、CI、静的解析、リポジトリ構造――に接続し、どの検証地点で何を判定するかを、実装可能な手続きとして記述する。

# 4
前段の割り当てを「実装可能な手続き」に落とすとき、まず確認すべきことがある。ここでいうレールは思想ではなく、リポジトリの中に置かれ、CIの中で実行され、統合の可否を決める“物”である。したがって「境界・ドメイン・アーキテクチャ」という観点で割り当てたものは、それぞれ対応する成果物（仕様ファイル、テスト、静的検査、差分検査）に接続されなければならない。固定化の条件が外側から定義される、というのは結局、「統合してよいか」を判定する入力がコードの外側に存在し、その入力に照らして機械的に落とされる、という形になる。

境界の契約を“物”にする最短経路は、OpenAPIのような機械可読な仕様を単一の参照点として持つことだ。境界で固定したいのは外形であり、外形は差分として検出できる形を取る必要がある。OpenAPIがリポジトリの中にあり、それをもとにサーバ側の型やインターフェース、クライアント側の型が生成されるなら、探索主体が内部実装をどういじっても外形はそこから逸れにくくなる。さらに固定化の条件として「互換性違反がない」を置くなら、統合前にOpenAPI差分を比較して破壊的変更を検出する手続きが成立する。ここで重要なのは「互換性を守れ」という気持ちではなく、「互換性違反の形」を定義して差分で落とすことだ。そうすると、境界のレールは「仕様ファイル＋差分検査＋型生成」という組として具体化される。

ドメイン側は逆で、仕様ファイルだけでは十分にならない。ドメインで固定したいのは外形ではなく性質であり、性質はコード上の振る舞いとしてしか現れないからだ。ここで固定化の条件を“物”にする中心はテストになる。テストは「こう実装せよ」ではなく、「この結果に到達してはいけない」「この条件は常に満たされる」という禁止・保証の表現になる。探索主体に実装を委ねるならなおさら、固定化の条件は先に書かれている必要がある。言い換えると、TDDはこの文脈では単なる開発流儀ではなく、「固定化の条件を先に外部化する」ための手続きとして意味を持つ。実装を探索させる前に、落としてはいけない性質をテストとして先に置くことで、探索の結果が統合される条件が外側から与えられる。

アーキテクチャについては、構造そのものを“物”にする必要がある。責務分離や依存方向は、ドキュメントで宣言しただけでは固定化の条件にならない。探索主体が複数の枝を生むなら、層の越境や依存の逆流もまた枝として自然に生まれる。ここで必要なのは「この層からこの層へ依存してよい／いけない」を機械が判定できる形にすることだ。Goならパッケージ構造そのものが制約になるし、静的解析やlintのルールとして「禁止されたimport」を落とすこともできる。TypeScriptでも同様に、モジュール境界とimport規則を検査対象にできる。こうしてアーキテクチャのレールは「ディレクトリ構造＋依存ルール＋静的検査」という組として具体化される。

ここまでをまとめると、レールは三種類の検証として現れる。境界は契約差分として検証され、ドメインは性質テストとして検証され、アーキテクチャは構造検査として検証される。そして「固定化」は、これらをすべて通過した変更だけに許される。実務上の固定化の単位は、多くの場合PRのマージであり、マージが“前提の更新”になる。だから検証地点は最終的にCIに集約される。もちろんローカルでも回せるが、固定化を許すかどうかの判定は、誰が実行しても同じ結果になる地点に置く必要がある。

この配置は、アプリが小さい間は過剰に見えるかもしれない。しかし、ここまでの論理が狙っているのは「小さい間にうまくいくこと」ではなく、「探索が高速・多分岐になっても前提が汚染されないこと」だ。規模が上がるほど、固定化の条件は増える。だが増やすべきものは無秩序なルールではなく、境界・ドメイン・アーキテクチャのいずれかに属する“検証可能な条件”である。そうして条件が増えても、構造は変わらない。探索空間の制約を与え、固定化の条件を定義し、検証地点で落とす――この型を保ったまま、対象が増えていくだけになる。

次に書くべきことは、この「三種類の検証」を、実際の技術選定とリポジトリ運用に接続することである。すなわち、どの成果物を単一参照点にするか（たとえばOpenAPI）、どの性質をテストとして外部化するか（不変条件の表現）、どの構造を静的に落とすか（依存方向の検査）、そしてそれらをCIのどの段階で走らせ、落ちたときに何が起きるか（統合されない、という事実）を、手続きとして書き下す。

# 5
次に必要なのは、ここまでを「技術選定」と「日々の運用」に落とすことである。レールが“物”である以上、どの成果物を一次情報として扱い、どの順序で検証を走らせ、失敗したときにどう振る舞うかが、設計の一部になる。ここでは、個別技術の紹介ではなく、なぜその技術がこの型に接続されるのか、という導出に集中する。

境界に関しては、OpenAPIを契約の一次情報として扱うのが自然である。境界で固定したいのは外形であり、外形は人間の説明文ではなく差分として検出できる必要がある。OpenAPIは外形を機械可読な形で固定でき、かつ差分比較によって契約の変化を検出できる。したがって境界のレールは、(1) OpenAPIを単一参照点として置き、(2) そこから型やクライアントを生成することで探索主体の自由度を境界の内側へ押し込み、(3) CIで契約検証と差分検査を走らせて契約に反する変更が固定化されないようにする、という手続きとして構成される。この手続きの利点は、実装者の注意力ではなく「差分」を根拠に固定化可否を決められる点にある。

ただし、OpenAPIを単一参照点にすると決めた瞬間から、別の論点が生まれる。OpenAPIが変わるということは、内部実装が変わるのではなく、外部に対する約束が変わるということである。ここでは変更を「実装変更」と「契約更新（仕様更新）」に分けて扱う。実装変更とは、OpenAPIで表現される外形を変えずに内部実装を変える変更である。一方、契約更新とは、外から見た約束そのものを変える変更であり、具体的にはリクエスト／レスポンスのスキーマ変更（フィールド追加・削除、型変更、required/optionalの変更、バリデーション制約の変更）、エンドポイントの変更（パス、HTTPメソッド、クエリの意味）、エラー表現の変更（構造、分類、エラーコード体系、同一条件で返るステータス）、認証・認可の前提変更などが該当する。

契約更新を扱うときに中心になるのが互換性である。本ドキュメントで言う互換性とは原則として後方互換性を指し、既存のクライアントがコード変更なしで動き続けることを意味する。後方互換性を破る変更（破壊的変更）とは、例えば既存フィールドの削除、型変更、必須化、エンドポイントの削除や変更、エラーの意味変更など、既存クライアントの前提を壊す変更である。したがって契約更新を固定化するには、「差分として何が変わったか」だけでなく、「その差分が後方互換性を破っているか」を判定できる必要がある。

さらに、破壊的変更を伴う契約更新には移行が必要になる。ここで言う移行とは、契約変更に追従するための手順であり、利用側（フロントエンドや他サービス）が壊れずに追従できるようにする措置を指す。典型的には、(a) 後方互換を保ったまま段階移行する（新仕様を追加し旧仕様を一定期間残し、移行完了後に旧仕様を廃止する）、(b) バージョニングで並行稼働する（v1とv2を併存させ、期限を決めて旧版を終了する）、(c) 利用側と同時リリースできる範囲に限って即時変更する、のいずれかになる。移行が定義されない破壊的変更は、固定化される前提として扱えない。

ここで言いたいのは運用の厳格さではない。「探索と固定の分離」を境界の一次情報にも適用する、という一貫性である。探索主体は契約に合わせて実装を探索することはできるが、契約そのものを探索結果として揺らがせてはならない。OpenAPIを変更する行為は探索ではなく設計判断として扱い、契約更新は互換性と移行を含む固定化の条件を満たしたときだけ統合される、という構造を境界にも適用する。

ドメインについては、テストを固定化の条件として置く、という方針が具体的な設計に変換される。ここで重要なのは、テストが「実装の正しさを証明する」ためにあるのではなく、「固定してはいけない枝」を統合前に落とすための装置として使われる、という位置づけである。テストの記述対象は、理想的には“やり方”ではなく“性質”である。禁止された状態遷移、成立してはいけない組み合わせ、権限違反、整合性違反といったものは、探索主体がどう実装しても変わってはいけない。したがって、それらを先にテストとして外部化し、探索結果をそのテストに通すことで、固定化の条件が手続きとして成立する。

このとき、ユニットテストだけに寄せる必要はない。境界の契約とドメインの不変条件は、しばしば統合点で破れる。だから、性質を表現するテストは層を跨ぐ形になることがある。ここで重要なのは「どの粒度のテストが正しいか」ではなく、「固定化の条件として必要な性質が表現されているか」である。探索主体に委ねる自由度が大きいほど、固定化の条件は抽象度の高い性質として表現され、テストはその性質に対する反例を潰す形になる。

アーキテクチャについては、静的検査の導入が最も直接的にレールへ接続される。依存方向や層の越境は、探索主体が局所的な都合で踏み抜きやすい。だから、構造の固定化条件は、コードレビューで気づく前に機械的に落とせる形にするのが望ましい。Goならパッケージ構造とimport制約がこの役割を担えるし、TypeScriptでもモジュール境界とimport規則を検査対象にできる。ここでの静的検査は、スタイルを揃えるためではなく、探索空間の制約が破られていないことを判定するための装置になる。

以上を踏まえると、CIは単なる自動テストの実行環境ではなく、固定化の関所として設計される。CIの各段階は、それぞれ別の種類の違反を落とす。境界は契約差分として落とし、ドメインは性質テストとして落とし、アーキテクチャは構造検査として落とす。重要なのは順序ではなく、固定化可否がこの三種類の判定に従属する、という関係を明示することだ。

この構造を日々の開発に落とすと、作業単位は自然に「探索」と「固定化準備」に分かれる。探索主体に実装を生成させるフェーズでは、人間は意図を言語化し、レールに従う形に誘導する。AIの出力が多分岐になること自体は前提として受け入れつつ、まずは一つの実装案を生成させる。その案が固定化の条件を満たすかを検証し、満たさなければ修正または再生成によって枝を切り落とす。一方で固定化準備のフェーズでは、人間は候補をレールに照らして切り落とし、必要ならレール側（契約・不変条件・依存制約）を補強し、再び探索へ戻す。

次に記述すべきは、この往復運動を壊さないために、リポジトリの中にどの成果物を置くか、そしてそれらをどう変更するかの規則である。すなわち、契約はどこに置かれ、テストはどの層に配置され、依存方向のルールはどの形で宣言され、CIはそれらをどう参照し、変更が失敗したときにどの地点で止まるのか。ここまで落とせれば、本設計はリポジトリ上の成果物とCI上の検証手続きとして記述が閉じる。