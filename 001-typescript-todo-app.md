
## 概要
- シンプルなTodoWebアプリケーション
- モノレポ構成（`backend/`, `frontend/`）
- TypeScript / ES Modules（`"type": "module"`）

## バックエンド
- 言語/実行: TypeScript, Node.js, tsx
- Webフレームワーク: Fastify, @fastify/cors
- 認証/認可: JSON Web Token（jsonwebtoken）
- バリデーション: Zod
- ORM/DB: Prisma, PostgreSQL
- テスト: Vitest, Supertest

## フロントエンド
- UI: React 18, React DOM
- 状態管理: Zustand
- データ取得: TanStack React Query
- ビルド: Vite
- CSS: Tailwind CSS, PostCSS, Autoprefixer
- テスト: Vitest, Testing Library, JSDOM
- E2E: Playwright

## 開発・品質
- 型チェック: TypeScript (`tsc`)
- Lint: ESLint
- フォーマット: Prettier
- 依存管理: npm（package-lock.json）

## インフラ/ローカル実行
- コンテナ: Docker Compose
- DBコンテナ: PostgreSQL 16（本番/テスト用 compose）

## アーキテクチャ概要図（簡易）
```
[HTTP/Transport]
   Handlers (Fastify routes)
            |
         Usecases
            |
         Domain
 (entities / valueObjects / errors)
            |
      Repositories
            |
   Infrastructure (Prisma)
```

## レイヤードアーキテクチャの特徴
- ドメイン層が中心で、`domain/` にエンティティ・値オブジェクト・ドメインエラーが集約
- ユースケース層（`usecases/`）にアプリケーションの処理フローを記述される
- ハンドラ層（`handlers/`）がHTTPリクエスト/レスポンスの変換と入力検証を担当
- リポジトリ層（`repositories/`）が永続化の抽象化を担い、インフラ層で実装
- 依存の向きが「外側 → 内側」になりやすく、ドメインがフレームワークに依存しにくい構造
- 変更が少ないものを外側に置き、変更が多いものをより内側に置くことで変更耐性を高くしている

## アプリケーション設計の中心
### TypeScript

本プロジェクトにおいてTypeScriptは必須ではない。学習用の小規模アプリであり、コード量・変更頻度・チーム人数が同時に増加していく状況をこのプロジェクト自身が引き受けるわけではないからだ。それでもTypeScriptを採用したのは、実務の現場ではこれらの要因が並行して増え、変更の影響範囲を人間が追い切れなくなる局面が繰り返し訪れるという前提に立ったとき、破壊的変更を実行前（編集時／コンパイル時）に露出させ、修正漏れを抑える“保険”として機能するからである。JavaScriptはWeb開発の支配的な生態系であり、そこから降りないという選択には強い合理性がある一方で、JavaScript単体では「値の形」「依存関係の接続」が崩れたことを静的に強制検出する仕組みが標準で備わっているとは言い難い。TypeScriptはこの現実に対して、既存のJavaScript資産と接続したまま型検査というレイヤを追加し、内部整合性の破綻を早期に見つけやすくする方向で設計されている。

いわゆる「上位互換」という表現がしばしば使われるのは、TypeScriptがJavaScriptのコード資産や運用と両立しやすい形で導入できる、という意味においてである。TypeScriptは型注釈などの情報をコードに付加するが、それは最終的に消去され、実行時の挙動自体はJavaScriptとして動く。つまり、実行環境を刷新するのではなく、開発時に“破綻を早く見つける回路”を足すというアプローチを取っている。この設計は、理論的な完全性よりも現実的な移行性や開発体験を優先しているため、型体系の内部には意図的な抜け道も存在する。たとえばanyや型アサーションのように、開発者が型検査を迂回できる機構がある以上、TypeScriptが与える安全性は「絶対的保証」ではなく、運用の強度（どれだけ迂回を許さないか）によって決まる性格を持つ。それでもなお、破壊的変更の早期検出という一点に関して得られる利益は大きい。たとえばTodo型に必須フィールドを追加する変更は、生成・更新・表示など複数箇所に影響が波及しやすいが、TypeScriptであれば未対応箇所が型エラーとして露出し、修正漏れを抑えやすい。私がこのプロジェクトでTypeScriptに期待する中心はまさにここで、内部の変更がどこに波及するかを実行前に炙り出す能力である。

ただし、この早期検出が主に効くのはコードベース内部であり、HTTPのような外部境界に属する契約についてはTypeScriptだけでは担保できない。APIレスポンス形の変更や更新エンドポイントの入力変更は、別プロセスが返すデータや外部から流入する実行時データを前提とするため、「型としてそう書いてある」ことと「実際にその形で来る」ことが分離してしまう。したがって外部境界では、「仕様の一次ソースをどこに置くか」が設計上の要点になる。ここでOpenAPIを一次ソースに置く、という選択は標準的で強力だが、本プロジェクトのようにTypeScriptを主言語とし、境界の不整合を実行時に確実に落としたいという関心を中心に置くなら、実装に近いスキーマ（Zod）を一次ソースとして固定し、必要に応じてOpenAPIを生成する方針が自然だと考える。なお、今回のスタック一覧にはOpenAPI生成の具体ツールが含まれていないので、ここは「方針として正当化されるが、この規模では必須ではなく、必要が生じた段階で追加する余地がある」という位置づけに留めるのが誠実だろう。

その理由は、一次ソースに求めているものが「読むための仕様書」よりも先に「境界を実際に縛る制約」だからである。OpenAPIは境界の形を記述するための優れた仕様だが、それ自体はランタイムで入力を拒否したり、データを安全な形にパースしたりする“実行可能な制約”ではない。一方Zodは、境界で受け取るデータを実行時に検証し、必要ならパースして“内部が扱ってよい形”に整えるところまでを直接担える。つまり「この形以外は入れない」という制約が、ドキュメントではなくコードとして実行される。その上で、スキーマからTypeScriptの型情報へも接続しやすく、境界で定義した制約を内部の型（ユースケース／ドメイン）へ自然に持ち込める。内部はTypeScript、外部境界はZodという分担は、あなたが言う「論理的導出の補強」を、実行可能な形で実装に落とすための筋道になっている。

### モノレポ

私はモノレポ構成を選ぶ理由を、「閉じた系の数を減らして外部境界を減らす」ことに置いている。境界は危うい領域であり、とくにフロントエンドとバックエンドのように別の関心・別の実装が接続する場所では、契約のズレがバグとして顕在化しやすい。もっとも、ここで言う“境界を減らす”とは、HTTPという外部境界そのものを消すという意味ではない。実務ではフロントとバックが別デプロイになる可能性を排除しづらく、境界のズレ（version skew）は原理的に起こりうる。したがってモノレポの価値は、境界を消すことではなく、境界をまたぐ変更と契約管理を一箇所に集約し、ズレが起きても壊れにくく、壊れるなら早く分かる状態を作る点にある。

TypeScriptは、フロントやバックという各アプリケーション内部では、型によって依存関係の不整合を実行前に露出させられるため、内部の論理的整合性を保つ助けになる。しかし外部境界、特にTodoの入出力スキーマのように実行時にデータが行き来する領域では、TypeScriptだけでは真偽を担保できない。このプロジェクトで最も危ういのはまさにその入出力スキーマであり、ここを“契約の一次ソース”として固定する必要がある。私はその一次ソースを仕様書（OpenAPI）そのものに置くのではなく、実装に近いスキーマ（Zod）に置き、必要に応じてOpenAPI等の仕様書をそこから生成する方針が自然だと考える。なぜなら、境界で本当に必要なのは「読むための正典」よりも先に「動く制約」であり、Zodは実行時に入力を検証・パースして内部に通す形で境界の真偽を直接拘束できるからである。

この前提に立つと、モノレポは「契約の一次ソース（Zodスキーマ）と、その変更に追随するフロント／バックの修正と検証」を同一リポジトリ・同一CI・同一レビューの中に束ねることで、契約のドリフトを起こしにくくする。別デプロイを許すなら、なおさら同時更新だけを前提にできないため、契約変更には後方互換を意識した運用が必要になるが、モノレポであれば契約の変更と互換性の確認を同じ場所で継続的に扱える。小規模で学習用であり将来的にスケールしないことが分かっている以上、複数リポジトリやサービス分割によって境界を増やし、契約維持や運用の不確実性まで背負うより、モノレポで境界契約の管理を集中させたほうが学習の焦点も散らず、合理的だと判断する。

### レイヤードアーキテクチャ

レイヤードアーキテクチャを採用した理由は、変更に弱い要素（HTTPフレームワーク、ORM、入出力の形式、認証など）と、変更に対して安定させたい核（Todoという概念に関する規則や、それを用いた操作の単位）を切り分け、依存の向きを外側から内側へ揃えることで、設計の中心を「壊れやすい境界」ではなく「保ちたい整合性」に置くためである。ここで中心に据えるのはドメイン層であり、domain/にはエンティティ・値オブジェクト・ドメインエラーを集約する。重要なのはファイル配置それ自体ではなく、ドメイン層が「この概念が概念として成立するために常に守られるべき規則（不変条件）」を引き受ける点にある。たとえばタイトルの意味的制約や、状態遷移に伴う整合性（statusとdoneAtの関係など）は、HTTPやDBの都合から独立して表現され、守れない場合はドメイン語彙としてのエラーになる。

ユースケース層（usecases/）は当初「ユーザー操作単位の境界」として置き、操作単位でのテストを可能にして、テストが仕様として妥当に表現されやすくするための層だと捉えていた。今回の実装では実際に複数の関心（永続化まで含む処理の束ね）を担っていたのはサービス層であり、ユースケース層はサービス呼び出しと入出力の整形に寄った薄い境界になっている。したがって現状の理解としては、ユースケース層は「ユーザー意図に対応した入口を明示し、操作単位のテストと仕様表現の単位を与える層」であり、処理フローの束ねや文脈依存の判断はサービス層が引き受ける、という役割分担として捉える。将来的に関心の再利用や複雑化が進めば、サービス層をより小さな関心単位に分割し、ユースケースがそれらを統率する形へ寄せる余地はあるが、少なくとも現時点では「境界を明確にしテストしやすい単位を作る」ことがユースケース層の実務的な効能になっている。

ハンドラ層（handlers/）はHTTPの外部境界を担当し、リクエスト／レスポンスの変換、入力検証、エラーのHTTP表現へのマッピングといった“翻訳”を担う。ここでの核心は、外部から流入するデータは実行時の不確実性を含むため、内部に危険な形のまま持ち込まない、という点にある。したがって入力検証はハンドラ層で実行時に行い、内部へ渡すのは検証・整形済みのデータに限定する。バリデーションは一枚岩ではなく、外部入力の「形」の検証は境界で、概念の「意味（不変条件）」はドメインで、IOや状態に依存する「文脈」の検証はサービスで扱う、という分解が設計上の肝になる。この分解によって、同じ制約を複数箇所に重複して書いてズレを増やす事故を避けつつ、境界の危うさを管理可能な形にできる。

永続化については、repositories/が抽象を担い、インフラ層がその実装を提供する。ここで重要なのは、ORMやDBスキーマの都合を内側へ逆流させないことであり、内側（ユースケース／サービス）が必要とする操作をインタフェースとして定義し、外側がそれを満たす形で実装する、という依存逆転の構図を保つ点である。こうして依存の向きを「外側→内側」に揃えることで、フレームワークや永続化手段の変更があってもドメインの核が引き回されにくくなり、同時にテストは境界（ユースケース単位・サービス単位・ドメイン単位）ごとに書き分けやすくなる。結果として、境界で起きやすいズレを早く発見し、内部の整合性を維持しやすい構造として、レイヤードアーキテクチャを採用している。

## 技術スタック
- ES Modules  
ES Modules（ESM）は、JavaScriptの標準モジュール方式で、`import/export` によって依存関係を宣言する仕組みである。Node.jsの実行時に「どのファイルがどの順序で読み込まれ、どの名前がどこに束縛されるか」という内部境界を安定させるには、CJSとESMの混在を避けて規約を固定するのが合理的であり、`"type": "module"` 等でESMに寄せる判断は「境界の揺れを減らす」目的に整合する。

- Node.js  
Node.jsは、V8上でJavaScript/TypeScript由来のコードをサーバ側で動かす実行環境で、非同期I/Oを基盤としてHTTPサーバやDBアクセスを扱える。今回の学習の中心が「HTTPやDBといった外部境界をどう扱うか」にある以上、フロントと同じ言語圏に留まり、余計な言語境界（別言語のビルド・デプロイ・運用差）を増やさずに境界設計へ集中できる点で採用が妥当になる。

- tsx  
`tsx` は、開発時にTypeScriptをそのまま実行できるランナーで、トランスパイルや複雑な起動手順を意識せずに `tsx src/index.ts` のように動かせる。学習プロジェクトでは反復速度が価値であり、起動・ビルドの摩擦が増えるほど境界（入力検証、API契約、DB整合）に向けたい注意が分散するため、実行の手間を減らす `tsx` は「本題以外の境界を増やさない」選択として合理的である。

- Fastify  
FastifyはNode.js向けのWebフレームワークで、ルーティング、リクエスト処理、プラグイン拡張などを提供し、HTTPサーバの構造を組み立てるための基盤である。ここでの導出理由は「フレームワーク選好」ではなく、HTTPという外部境界の責務（入力の検証、変換、エラー表現、認可など）をハンドラ層へ押し込み、ドメインやサービスへHTTP詳細を逆流させない“器”が必要だからであり、構成を整理しやすいFastifyはレイヤードの狙いと整合する。

- @fastify/cors  
`@fastify/cors` はFastifyにCORS設定を追加するプラグインで、ブラウザが強制する「どのオリジンからAPIを呼んでよいか」という境界条件をサーバ側で明示できる。フロントとバックが別オリジンになりうる構成ではCORSは避けられない外部境界であり、暗黙の挙動に頼らず設定をコードとして固定することで、境界起因の不具合を観測可能な形に落とせる点で採用が妥当になる。

- JSON Web Token（jsonwebtoken）  
JWTは、署名付きのトークンにユーザー識別などの情報を載せ、HTTP境界を跨いで主体（誰が操作しているか）を運ぶ方式である。`jsonwebtoken` はJWTの発行・検証を行うライブラリで、署名検証によって境界を跨いだ情報の改ざん検知を可能にする。主体の同一性は典型的な境界問題であり、JWTはそれを明示的に扱える一方、失効・ローテーションなど運用論点も増えるため、この規模では「境界の題材としてどこまで掘るか」を割り切れる余地がある。

- Zod  
Zodは、スキーマ（データの形）を宣言し、そのスキーマに基づいて実行時に検証・パースを行うライブラリで、同時にTypeScriptの型推論にも接続できる。TypeScriptが閉じた系の内部整合性を強くするのに対し、ZodはHTTP等の外部境界で「型としてそう書いてある」と「実際にその形で来る」の乖離を埋める“動く制約”として機能する。境界の真偽をランタイムで拘束し、内部へ安全な形だけを通すという関心に対して最も直接に導出される選択である。

- Prisma  
PrismaはTypeScript向けORMで、DBスキーマ定義、型生成、マイグレーション、クエリAPIを提供し、DBアクセスを型の通った形で扱えるようにする。DBは外部境界であり、ここが曖昧だと内部の論理が破綻しやすいが、Prismaは「DB境界の形」をコード生成とマイグレーションの流れで管理しやすくする。repositories層の背後に置けば、ORM都合を内側へ逆流させにくいという意味でもレイヤードの狙いと一致する。

- PostgreSQL  
PostgreSQLはRDBMSで、制約、トランザクション、整合性保証など「データの正しさを外部境界側でも担保する」ための強い機能を持つ。境界の不整合を減らすという関心において、アプリの論理だけで全てを保証しようとせず、DB側の制約やトランザクションを利用できる土台を置くのは合理的であり、学習としても“外部境界の保証”を扱える。

- React 18  
ReactはUIをコンポーネントとして組み立て、状態と表示の関係を宣言的に管理するためのライブラリである。フロントエンドはブラウザ境界の内側にある別の閉じた系で、外部境界（API）から来る不確実なデータと、内部状態の整合をどう保つかが主要課題になる。Reactはこの関係を整理して表現しやすく、Webのデファクトとして学習価値も高いため採用が妥当になる。

- React DOM  
React DOMはReactコンポーネントをブラウザのDOMへ描画するレンダラーであり、ReactをWebで動かすための標準構成要素である。特別な設計意図を追加するというより、標準に寄せて余計な境界（独自レンダラーや特殊構成）を増やさない、という意味で合理的な選択になる。

- Zustand  
Zustandは、最小限のAPIでグローバル状態を管理できる状態管理ライブラリで、ボイラープレートが少なくストアを作れる。小規模アプリでも状態の所在が曖昧になると境界（入力→状態→表示）で破綻しやすいが、Zustandは過剰な抽象を持ち込まずに状態を明示化できる。したがって「境界以外の複雑さを増やさずに状態境界を扱う」選択として説明できる。

- TanStack React Query  
React Queryは、APIから取得するサーバ状態の取得・キャッシュ・再検証・同期を管理するライブラリである。HTTP境界の向こう側のデータは不確実で、更新タイミングや整合の扱いが問題になりやすいが、React Queryはその不確実性を前提とした枠組みを提供する。外部境界を中心関心に置くなら、サーバ状態を体系的に扱える点で導出が立つ。

- Vite  
Viteはフロントエンド開発用のビルドツール／開発サーバで、高速な起動とHMRを提供し、TypeScript/Reactの標準構成にも馴染む。学習の主題が境界設計である以上、ツールの遅さや設定地獄という別の境界で思考を消耗しないことが重要であり、反復速度を確保できるViteは妥当な選択になる。

- Tailwind CSS  
Tailwind CSSはユーティリティファーストのCSSフレームワークで、細かなスタイルをクラスの組み合わせとして適用する。UIの見た目は本題から注意を逸らしやすいが、最低限の整形は必要であるため、独自のCSS設計や命名規約という別の関心事（別の境界）を増やさずに一定品質へ到達しやすい点で採用が合理的になる。

- PostCSS  
PostCSSはCSSを変換するための処理パイプラインで、Tailwindの展開や各種プラグイン処理の土台として使われる。単体で境界設計の核を担うわけではないが、採用したフロント構成（Tailwind等）を成立させる標準的な要素として必要になる、という位置づけが自然である。

- Autoprefixer  
AutoprefixerはPostCSSプラグインで、ブラウザ互換のためにベンダープレフィックスを自動付与する。ブラウザ差分は実行環境境界の一種であり、手作業で境界条件を増やさず自動化するのは合理的だが、近年はターゲット次第で効果が相対化するため、ここも“標準構成として付随する要素”に近い。

- Vitest  
VitestはVite系のテストランナーで、TypeScriptとの相性が良く高速にテストを回せる。テストは「仕様（外部）とコード（内部）の境界」を往復して整合を確認する装置であり、境界中心の学習では試行回数が重要になる。フロント／バックでテスト基盤を寄せやすい点も、境界の分裂を防ぐ意味で妥当性がある。

- Supertest  
SupertestはNode.js向けのHTTPテスト支援ライブラリで、サーバを実際に叩いてレスポンスを検証できる。Zod等で縛ったはずの契約がHTTP境界を通して本当に成立しているかを確認するには統合テストが有効であり、境界が中心関心である以上導入理由は立つ。ただしFastifyには別のテスト手段もあるため、必須というより「HTTP境界の検証を手早く書く選択肢」として妥当である。

- Testing Library  
Testing LibraryはUIテストのためのユーティリティ群で、「実装詳細」ではなく「ユーザーがどう操作し、何が見えるか」という観点でテストを書きやすくする。ユースケース境界を操作単位で捉え、テストを仕様表現として扱いたいという目的と整合し、UIを境界の外から観察する形で検証できる点が導出理由になる。

- JSDOM  
JSDOMはNode.js上でDOMをエミュレートする仮想ブラウザ環境で、実ブラウザを起動せずにUIテストを回せる。ブラウザ境界を完全再現するのではなく、軽量な環境で反復速度を確保し、境界検証を高速に回すための基盤として位置づけられる。

- Playwright  
PlaywrightはE2Eテストツールで、実ブラウザを自動操作し、画面遷移やネットワークを含む最外部境界まで検証できる。境界中心の関心とは強く整合するが、実行コストが高いので、常時フル活用が必須というより「最終境界での破綻が問題になったときに厚くする」段階導入の余地も含めて妥当化できる。

- ESLint  
ESLintは静的解析（Lint）ツールで、バグになりやすい記法や規約違反を検出し、コード品質を一定に保つ。境界設計の議論そのものではないが、些末なミスが増えると変更の差分が読みにくくなり、境界起因の不具合の切り分けが難しくなる。ノイズを減らし観測可能性を上げる基盤として採用が妥当である。

- Prettier  
Prettierは自動フォーマッターで、コード整形を機械に委ねて表記揺れを排除する。設計の正しさを直接保証するわけではないが、差分が“意味の差分”として見えやすくなり、境界のズレや修正漏れを追う際の摩擦を下げるという意味で合理性がある。

- npm  
npmはNode.jsのパッケージマネージャで、依存解決とスクリプト実行を提供する。依存管理はツールチェーンの境界であり、ここに独自性を持ち込みすぎると学習が逸れる。標準的で摩擦が少ないnpmを採るのは「本題以外の境界を増やさない」ための妥当な選択になる。

- Docker Compose  
Docker Composeは複数コンテナ（アプリ、DBなど）をまとめて起動・設定できるツールで、開発環境の再現性を上げる。環境差は典型的な外部境界であり、ローカルでDBや周辺を安定再現できないと、境界設計の検証がノイズに埋もれる。環境境界を固定して学習の焦点を守るために導入が妥当になる。

- PostgreSQL 16  
PostgreSQL 16をComposeでバージョン固定するのは、DBという外部境界の挙動を安定させるためである。同じSQLでもバージョン差や設定差で挙動が揺れると学習が誤誘導されるため、境界条件を明示的に固定し、再現性を確保する意図が導出理由になる。

## 課題
- フロントエンドとバックエンドの境界において契約がかたまってない
  - OpenAPIやZod等を使って境界の契約をかためるべき
