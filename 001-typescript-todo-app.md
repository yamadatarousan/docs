# TypeScript Todo App 技術スタック

## 概要
- モノレポ構成（`backend/`, `frontend/`）
- TypeScript / ES Modules（`"type": "module"`）

## バックエンド
- 言語/実行: TypeScript, Node.js, tsx
- Webフレームワーク: Fastify, @fastify/cors
- 認証/認可: JSON Web Token（jsonwebtoken）
- バリデーション: Zod
- ORM/DB: Prisma, PostgreSQL
- テスト: Vitest, Supertest

## フロントエンド
- UI: React 18, React DOM
- 状態管理: Zustand
- データ取得: TanStack React Query
- ビルド: Vite
- CSS: Tailwind CSS, PostCSS, Autoprefixer
- テスト: Vitest, Testing Library, JSDOM
- E2E: Playwright

## 開発・品質
- 型チェック: TypeScript (`tsc`)
- Lint: ESLint
- フォーマット: Prettier
- 依存管理: npm（package-lock.json）

## インフラ/ローカル実行
- コンテナ: Docker Compose
- DBコンテナ: PostgreSQL 16（本番/テスト用 compose）

## 依存関係バージョン（主要）
### ルート（バックエンド/共通）
- fastify ^4.29.0
- @fastify/cors ^9.0.1
- @prisma/client ^5.22.0 / prisma ^5.22.0
- jsonwebtoken ^9.0.3
- zod ^3.24.1
- vitest ^2.1.8 / @vitest/coverage-v8 ^2.1.9
- typescript ^5.6.3
- eslint ^9.39.2 / prettier ^3.8.1
- tsx ^4.16.2

### フロントエンド
- react ^18.3.1 / react-dom ^18.3.1
- @tanstack/react-query ^5.59.10
- zustand ^4.5.5
- vite ^5.4.11 / @vitejs/plugin-react ^4.3.4
- tailwindcss ^3.4.15 / postcss ^8.4.49 / autoprefixer ^10.4.20
- vitest ^2.1.8
- @playwright/test ^1.55.0

## アーキテクチャ概要図（簡易）
```
[HTTP/Transport]
   Handlers (Fastify routes)
            |
         Usecases
            |
         Domain
 (entities / valueObjects / errors)
            |
      Repositories
            |
   Infrastructure (Prisma)
```

## レイヤードアーキテクチャの特徴
- ドメイン層が中心で、`domain/` にエンティティ・値オブジェクト・ドメインエラーが集約
- ユースケース層（`usecases/`）にアプリケーションの処理フローを記述される
- ハンドラ層（`handlers/`）がHTTPリクエスト/レスポンスの変換と入力検証を担当
- リポジトリ層（`repositories/`）が永続化の抽象化を担い、インフラ層で実装
- 依存の向きが「外側 → 内側」になりやすく、ドメインがフレームワークに依存しにくい構造

## 課題
- フロントエンドとバックエンドの境界において契約がかたまってない
  - OpenAPI等を使って境界の契約をかためるべき

## 技術スタック
### TypeScript

本プロジェクトにおいてTypeScriptは必須ではない。学習用の小規模アプリであり、コード量・変更頻度・チーム人数が同時に増加していく状況をこのプロジェクト自身が引き受けるわけではないからだ。それでもTypeScriptを採用したのは、実務の現場ではこれらの要因が並行して増え、変更の影響範囲を人間が追い切れなくなる局面が繰り返し訪れるという前提に立ったとき、破壊的変更を実行前（編集時／コンパイル時）に露出させ、修正漏れを抑える“保険”として機能するからである。JavaScriptはWeb開発の支配的な生態系であり、そこから降りないという選択には強い合理性がある一方で、JavaScript単体では「値の形」「依存関係の接続」が崩れたことを静的に強制検出する仕組みが標準で備わっているとは言い難い。TypeScriptはこの現実に対して、既存のJavaScript資産と接続したまま型検査というレイヤを追加し、内部整合性の破綻を早期に見つけやすくする方向で設計されている。

いわゆる「上位互換」という表現がしばしば使われるのは、TypeScriptがJavaScriptのコード資産や運用と両立しやすい形で導入できる、という意味においてである。TypeScriptは型注釈などの情報をコードに付加するが、それは最終的に消去され、実行時の挙動自体はJavaScriptとして動く。つまり、実行環境を刷新するのではなく、開発時に“破綻を早く見つける回路”を足すというアプローチを取っている。この設計は、理論的な完全性よりも現実的な移行性や開発体験を優先しているため、型体系の内部には意図的な抜け道も存在する。たとえばanyや型アサーションのように、開発者が型検査を迂回できる機構がある以上、TypeScriptが与える安全性は「絶対的保証」ではなく、運用の強度（どれだけ迂回を許さないか）によって決まる性格を持つ。それでもなお、破壊的変更の早期検出という一点に関して得られる利益は大きい。たとえばTodo型に必須フィールドを追加する変更は、生成・更新・表示など複数箇所に影響が波及しやすいが、TypeScriptであれば未対応箇所が型エラーとして露出し、修正漏れを抑えやすい。私がこのプロジェクトでTypeScriptに期待する中心はまさにここで、内部の変更がどこに波及するかを実行前に炙り出す能力である。

ただし、この早期検出が主に効くのはコードベース内部であり、HTTPのような外部境界に属する契約についてはTypeScriptだけでは担保できない。APIレスポンス形の変更や更新エンドポイントの入力変更は、別プロセスが返すデータや外部から流入する実行時データを前提とするため、「型としてそう書いてある」ことと「実際にその形で来る」ことが分離してしまう。したがって外部境界では、「仕様の一次ソースをどこに置くか」が設計上の要点になる。ここでOpenAPIを一次ソースに置く、という選択は標準的で強力だが、本プロジェクトのようにTypeScriptを主言語とし、境界の不整合を実行時に確実に落としたいという関心を中心に置くなら、実装に近いスキーマ（Zod）を一次ソースとして固定し、必要に応じてOpenAPIを生成する方針が自然だと考える。

その理由は、一次ソースに求めているものが「読むための仕様書」よりも先に「境界を実際に縛る制約」だからである。OpenAPIは境界の形を記述するための優れた仕様だが、それ自体はランタイムで入力を拒否したり、データを安全な形にパースしたりする“実行可能な制約”ではない。もちろん周辺ツールで検証や生成を組み合わせればOpenAPI中心でも成立するが、運用としては「仕様書（OpenAPI）」「実装」「クライアント型」の三者がズレないように保守し続ける課題が残りやすい。一方Zodは、境界で受け取るデータを実行時に検証し、必要ならパースして“内部が扱ってよい形”に整えるところまでを直接担える。つまり「この形以外は入れない」という制約が、ドキュメントではなくコードとして実行される。その上で、スキーマからTypeScriptの型情報へも接続しやすく、境界で定義した制約を内部の型（ユースケース／ドメイン）へ自然に持ち込める。一次ソースをZodに置くことは、境界契約を“動く制約”として保持し、ズレが起きたときに最も確実に破綻させられる場所（境界）に正しさを固定する、という意味を持つ。

さらに、Zodを一次ソースにしたうえでOpenAPIを生成する構図は、「仕様書を捨てる」ことではなく「仕様書をドリフトしにくい形で持つ」ことでもある。人間が参照する仕様書や、他言語クライアントに渡すための形式としてOpenAPIが必要になる局面はありうるが、そのとき仕様書が実装と乖離していると、境界契約の議論自体が不毛になる。生成という形を介すことで、少なくとも“正しさの根拠”を一箇所（境界スキーマ）に固定し、仕様書はその写像として扱える。この方針は、TypeScriptを「内部の破壊的変更を早期に露出させるための道具」として採用した判断とも整合する。内部ではTypeScriptが波及箇所を炙り出し、外部境界ではZodが実行時の真偽を縛る。両者の分担が明確であるほど、境界に起因する不具合の温床を減らしつつ、実務で求められる変更耐性（スケールに伴う破綻の早期顕在化）に近い学習ができる、と考える。

## モノレポ

私はモノレポ構成を選ぶ理由を、「閉じた系の数を減らして外部境界を減らす」ことに置いている。境界は危うい領域であり、とくにフロントエンドとバックエンドのように別の関心・別の実装が接続する場所では、契約のズレがバグとして顕在化しやすい。もっとも、ここで言う“境界を減らす”とは、HTTPという外部境界そのものを消すという意味ではない。実務ではフロントとバックが別デプロイになる可能性を排除しづらく、境界のズレ（version skew）は原理的に起こりうる。したがってモノレポの価値は、境界を消すことではなく、境界をまたぐ変更と契約管理を一箇所に集約し、ズレが起きても壊れにくく、壊れるなら早く分かる状態を作る点にある。

TypeScriptは、フロントやバックという各アプリケーション内部では、型によって依存関係の不整合を実行前に露出させられるため、内部の論理的整合性を保つ助けになる。しかし外部境界、特にTodoの入出力スキーマのように実行時にデータが行き来する領域では、TypeScriptだけでは真偽を担保できない。このプロジェクトで最も危ういのはまさにその入出力スキーマであり、ここを“契約の一次ソース”として固定する必要がある。私はその一次ソースを仕様書（OpenAPI）そのものに置くのではなく、実装に近いスキーマ（Zod）に置き、必要に応じてOpenAPI等の仕様書をそこから生成する方針が自然だと考える。なぜなら、境界で本当に必要なのは「読むための正典」よりも先に「動く制約」であり、Zodは実行時に入力を検証・パースして内部に通す形で境界の真偽を直接拘束できるからである。

この前提に立つと、モノレポは「契約の一次ソース（Zodスキーマ）と、その変更に追随するフロント／バックの修正と検証」を同一リポジトリ・同一CI・同一レビューの中に束ねることで、契約のドリフトを起こしにくくする。別デプロイを許すなら、なおさら同時更新だけを前提にできないため、契約変更には後方互換を意識した運用が必要になるが、モノレポであれば契約の変更と互換性の確認（たとえば古い側が残っても壊れにくい変更か）を同じ場所で継続的に扱える。小規模で学習用であり将来的にスケールしないことが分かっている以上、複数リポジトリやサービス分割によって境界を増やし、契約維持や運用の不確実性（リリースのズレ、観測、障害切り分け等）まで背負うより、モノレポで境界契約の管理を集中させたほうが学習の焦点も散らず、合理的だと判断する。

## レイヤードアーキテクチャ

レイヤードアーキテクチャを採用した理由は、変更に弱い要素（HTTPフレームワーク、ORM、入出力の形式、認証など）と、変更に対して安定させたい核（Todoという概念に関する規則や、それを用いた操作の単位）を切り分け、依存の向きを外側から内側へ揃えることで、設計の中心を「壊れやすい境界」ではなく「保ちたい整合性」に置くためである。ここで中心に据えるのはドメイン層であり、domain/にはエンティティ・値オブジェクト・ドメインエラーを集約する。重要なのはファイル配置それ自体ではなく、ドメイン層が「この概念が概念として成立するために常に守られるべき規則（不変条件）」を引き受ける点にある。たとえばタイトルの意味的制約や、状態遷移に伴う整合性（statusとdoneAtの関係など）は、HTTPやDBの都合から独立して表現され、守れない場合はドメイン語彙としてのエラーになる。

ユースケース層（usecases/）は当初「ユーザー操作単位の境界」として置き、操作単位でのテストを可能にして、テストが仕様として妥当に表現されやすくするための層だと捉えていた。今回の実装では実際に複数の関心（永続化まで含む処理の束ね）を担っていたのはサービス層であり、ユースケース層はサービス呼び出しと入出力の整形に寄った薄い境界になっている。したがって現状の理解としては、ユースケース層は「ユーザー意図に対応した入口を明示し、操作単位のテストと仕様表現の単位を与える層」であり、処理フローの束ねや文脈依存の判断はサービス層が引き受ける、という役割分担として捉える。将来的に関心の再利用や複雑化が進めば、サービス層をより小さな関心単位に分割し、ユースケースがそれらを統率する形へ寄せる余地はあるが、少なくとも現時点では「境界を明確にしテストしやすい単位を作る」ことがユースケース層の実務的な効能になっている。

ハンドラ層（handlers/）はHTTPの外部境界を担当し、リクエスト／レスポンスの変換、入力検証、エラーのHTTP表現へのマッピングといった“翻訳”を担う。ここでの核心は、外部から流入するデータは実行時の不確実性を含むため、内部に危険な形のまま持ち込まない、という点にある。したがって入力検証はハンドラ層で実行時に行い、内部へ渡すのは検証・整形済みのデータに限定する。バリデーションは一枚岩ではなく、外部入力の「形」の検証は境界で、概念の「意味（不変条件）」はドメインで、IOや状態に依存する「文脈」の検証はサービスで扱う、という分解が設計上の肝になる。この分解によって、同じ制約を複数箇所に重複して書いてズレを増やす事故を避けつつ、境界の危うさを管理可能な形にできる。

永続化については、repositories/が抽象を担い、インフラ層がその実装を提供する。ここで重要なのは、ORMやDBスキーマの都合を内側へ逆流させないことであり、内側（ユースケース／サービス）が必要とする操作をインタフェースとして定義し、外側がそれを満たす形で実装する、という依存逆転の構図を保つ点である。こうして依存の向きを「外側→内側」に揃えることで、フレームワークや永続化手段の変更があってもドメインの核が引き回されにくくなり、同時にテストは境界（ユースケース単位・サービス単位・ドメイン単位）ごとに書き分けやすくなる。結果として、境界で起きやすいズレを早く発見し、内部の整合性を維持しやすい構造として、レイヤードアーキテクチャを採用している。

## 技術スタック（詳細: 説明 / 使いどころ / メリデメ / 構成例）
- モノレポ構成
  - 説明: `backend/` と `frontend/` を同一リポジトリで管理し、依存や設定を一元化。共通方針やスクリプトを共有しやすい。
  - 使いどころ: フロントとバックを同時に開発/運用する中規模以上のプロジェクト。
  - メリデメ: 共有が楽・変更追跡が容易 / リポジトリが肥大化しやすい。
  - 構成例: `backend/`, `frontend/`, `package.json` をルートに配置。
- TypeScript
  - 説明: 主要言語として静的型付けを導入し、API境界やドメインの型安全性を担保。リファクタ時の破壊的変更を検出しやすい。
  - 使いどころ: 型安全が重要なAPI/ドメイン設計、長期保守が前提のWebアプリ。
  - メリデメ: 型による品質向上 / 学習コストと型定義の手間。
  - 構成例: `tsconfig.json` と `src/` 配下のTSコード。
- ES Modules
  - 説明: `"type": "module"` により ESM を採用し、`import/export` を標準化。実行環境やビルド設定の一貫性を保つ。
  - 使いどころ: ESM対応のNode.js環境やモダンビルドを前提にする場合。
  - メリデメ: 標準準拠で相互運用性が高い / CJSとの互換で注意が必要。
  - 構成例: `package.json` に `"type": "module"` を設定。
- Node.js
  - 説明: バックエンド実行環境としてイベント駆動I/Oを活用。HTTPサーバーやDBアクセスの基盤となる。
  - 使いどころ: I/O中心のWeb APIやリアルタイム処理。
  - メリデメ: 高い並行処理性能 / CPU集約処理は工夫が必要。
  - 構成例: `backend/` でAPIサーバーを起動。
- tsx
  - 説明: TypeScript をトランスパイル無しで実行できるランタイム。開発時の起動やスクリプト実行を簡潔にする。
  - 使いどころ: 開発時のCLI実行、スクリプト実行。
  - メリデメ: セットアップが簡単 / 本番向け最適化は別途必要。
  - 構成例: `tsx src/index.ts` のように実行。
- Fastify
  - 説明: 軽量で高速なバックエンドWebフレームワーク。ルーティングやプラグイン拡張で構成を整理できる。
  - 使いどころ: 高速応答が必要なAPIサーバー。
  - メリデメ: 高性能・拡張性 / Express系と比べると情報量が少なめ。
  - 構成例: `fastify()` でサーバーを生成し `route` を追加。
- @fastify/cors
  - 説明: CORS設定を簡易化するFastifyプラグイン。フロントエンドからのAPIアクセス制御に使用。
  - 使いどころ: 別ドメイン/別ポートからAPIを呼ぶ構成。
  - メリデメ: 設定が簡潔 / 不適切設定でセキュリティリスク。
  - 構成例: `app.register(cors, { origin: ... })`。
- JSON Web Token（jsonwebtoken）
  - 説明: 認証/認可のトークン方式としてJWTを採用。署名検証やトークン発行に `jsonwebtoken` を使用。
  - 使いどころ: ステートレスな認証が必要なAPI。
  - メリデメ: サーバー側状態が不要 / 失効管理が難しい。
  - 構成例: `jwt.sign(payload, secret)` と `jwt.verify(...)`。
- Zod
  - 説明: 入力バリデーションとスキーマ定義を行うライブラリ。API入力の型推論と検証を同時に担う。
  - 使いどころ: APIの入力検証、フォーム検証。
  - メリデメ: 型推論が強力 / スキーマ記述が冗長になることがある。
  - 構成例: `z.object({ ... })` でスキーマ定義。
- Prisma
  - 説明: ORMとしてDBアクセスを抽象化。スキーマ定義、型生成、マイグレーション管理を提供。
  - 使いどころ: TypeScriptで型安全なDBアクセスをしたい場合。
  - メリデメ: DXが良い / 生SQL最適化が必要な場合は工夫が必要。
  - 構成例: `schema.prisma` と `prisma migrate`。
- PostgreSQL
  - 説明: アプリケーションのRDBMS。トランザクションやリレーショナル設計に利用。
  - 使いどころ: ACIDが必要な業務系データ。
  - メリデメ: 機能が豊富 / 運用コストがかかる。
  - 構成例: Prismaの `datasource` に `postgresql` を指定。
- Vitest
  - 説明: バックエンド/フロントエンド双方で使うテストランナー。高速な実行とTypeScript対応が特徴。
  - 使いどころ: 単体・統合テストの実行。
  - メリデメ: 高速・Vite連携 / Jest互換ではない部分がある。
  - 構成例: `vitest.config.ts` を用意。
- Supertest
  - 説明: HTTPエンドポイントの統合テストを支援。FastifyのAPIを実際に叩いて検証できる。
  - 使いどころ: APIの統合テスト。
  - メリデメ: 実運用に近い検証 / テスト実行が重くなりがち。
  - 構成例: `request(app.server).get("/...")`。
- React 18
  - 説明: フロントエンドUIライブラリ。コンポーネント指向で画面を構成する。
  - 使いどころ: SPAやダッシュボードなどのUI構築。
  - メリデメ: エコシステムが豊富 / 設計方針が必要。
  - 構成例: 関数コンポーネント + Hooks。
- React DOM
  - 説明: ReactコンポーネントをDOMへ描画するレンダラー。ブラウザ環境での描画を担当。
  - 使いどころ: WebブラウザでReactを動かす場合。
  - メリデメ: 標準レンダラー / 代替手段は限定的。
  - 構成例: `createRoot(...).render(<App />)`。
- Zustand
  - 説明: フロントエンドの状態管理ライブラリ。最小限のボイラープレートでストアを構成。
  - 使いどころ: グローバル状態が少量のアプリ。
  - メリデメ: シンプル / 大規模では設計が必要。
  - 構成例: `create((set) => ({ ... }))`。
- TanStack React Query
  - 説明: サーバー状態の取得/キャッシュ/再検証を管理。API通信の状態を標準化する。
  - 使いどころ: APIの非同期取得が多いUI。
  - メリデメ: キャッシュが強力 / 学習コストがある。
  - 構成例: `useQuery({ queryKey, queryFn })`。
- Vite
  - 説明: 高速なフロントエンドビルドツール。開発サーバーと本番ビルドを提供。
  - 使いどころ: モダンなフロントエンド開発。
  - メリデメ: 起動が速い / 一部古いプラグインと非互換。
  - 構成例: `vite.config.ts` を定義。
- Tailwind CSS
  - 説明: ユーティリティファーストCSSフレームワーク。クラス設計でスタイルを組み立てる。
  - 使いどころ: デザインを素早く組むUI。
  - メリデメ: 開発が速い / クラスが長くなる。
  - 構成例: `className="flex gap-2 ..."`。
- PostCSS
  - 説明: CSS変換パイプライン。Tailwindの処理やプラグイン連携の土台。
  - 使いどころ: CSSの自動変換や最適化が必要な場合。
  - メリデメ: 柔軟 / 設定が増えがち。
  - 構成例: `postcss.config.cjs`。
- Autoprefixer
  - 説明: ブラウザ互換性のためにベンダープレフィックスを自動付与。
  - 使いどころ: 複数ブラウザ対応が必要なUI。
  - メリデメ: 手作業削減 / 最新ブラウザ向けなら効果が薄い。
  - 構成例: PostCSSプラグインとして有効化。
- Testing Library
  - 説明: UIテストでユーザー視点の操作を重視するユーティリティ。DOMの操作と検証を支援。
  - 使いどころ: Reactコンポーネントのテスト。
  - メリデメ: ユーザー視点 / 細かな内部実装テストに不向き。
  - 構成例: `render(<App />)` + `screen.getBy...`。
- JSDOM
  - 説明: テスト用の仮想DOM環境。ブラウザ無しでUIテストを実行可能にする。
  - 使いどころ: CIでのフロントエンドテスト。
  - メリデメ: 実ブラウザより軽い / 互換差がある。
  - 構成例: テスト環境を `jsdom` に設定。
- Playwright
  - 説明: E2Eテストツール。実ブラウザでのシナリオ検証を自動化。
  - 使いどころ: 画面遷移や統合動作の検証。
  - メリデメ: 実運用に近い検証 / 実行コストが高い。
  - 構成例: `@playwright/test` でテスト記述。
- TypeScript（tsc）
  - 説明: 型チェック専用コマンド。コンパイルせず型検証だけを行う。
  - 使いどころ: CIの型チェックステップ。
  - メリデメ: 型安全の確保 / ビルド時間が増える。
  - 構成例: `tsc -p tsconfig.json --noEmit`。
- ESLint
  - 説明: 静的解析によるLint。コード品質やスタイル違反を検知。
  - 使いどころ: ルールに基づく品質維持。
  - メリデメ: 品質向上 / ルール調整が必要。
  - 構成例: `.eslintrc.*` を用意。
- Prettier
  - 説明: コードフォーマットの自動化。スタイルの一貫性を保つ。
  - 使いどころ: Lintとは別にフォーマットを統一したい場合。
  - メリデメ: ルール論争を回避 / 独自整形は難しい。
  - 構成例: `.prettierrc` を設定。
- npm
  - 説明: 依存管理とスクリプト実行の基盤。`package-lock.json` による固定化を前提。
  - 使いどころ: Node.jsプロジェクトの標準的な依存管理。
  - メリデメ: 互換性が高い / pnpm等と比較してディスク使用量が多い。
  - 構成例: `npm run dev` などのスクリプト。
- Docker Compose
  - 説明: ローカル実行用コンテナ編成ツール。アプリとDBをまとめて起動。
  - 使いどころ: 開発環境でのDB/サービス起動。
  - メリデメ: 再現性が高い / 初期学習が必要。
  - 構成例: `docker-compose.yml` で `app` と `db` を定義。
- PostgreSQL 16
  - 説明: compose内のDBコンテナ。開発/テスト環境を本番相当で揃える。
  - 使いどころ: ローカル開発/テストのDB。
  - メリデメ: 本番に近い挙動 / コンテナ起動が必要。
  - 構成例: `postgres:16` の公式イメージを使用。
